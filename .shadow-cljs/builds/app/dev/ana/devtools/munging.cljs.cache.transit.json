["^ ","~:output",["^ ","~:js","goog.provide('devtools.munging');\r\ngoog.require('cljs.core');\r\ngoog.require('clojure.string');\r\ngoog.require('devtools.context');\r\ngoog.require('goog.object');\r\ngoog.require('goog.string.StringBuffer');\r\ndevtools.munging.dollar_replacement = \"~\\uFE69~\";\r\ndevtools.munging.max_fixed_arity_to_scan = (64);\r\ndevtools.munging.get_global_scope = (function devtools$munging$get_global_scope(){\r\nreturn (devtools.context.get_root.cljs$core$IFn$_invoke$arity$0 ? devtools.context.get_root.cljs$core$IFn$_invoke$arity$0() : devtools.context.get_root.call(null));\r\n});\r\ndevtools.munging.js_reserved_QMARK_ = (function devtools$munging$js_reserved_QMARK_(x){\r\nvar temp__5733__auto__ = (function (){var temp__5733__auto__ = ((devtools.munging.get_global_scope.cljs$core$IFn$_invoke$arity$0 ? devtools.munging.get_global_scope.cljs$core$IFn$_invoke$arity$0() : devtools.munging.get_global_scope.call(null))[\"cljs\"]);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar o55594 = temp__5733__auto__;\r\nvar temp__5733__auto____$1 = (o55594[\"core\"]);\r\nif(cljs.core.truth_(temp__5733__auto____$1)){\r\nvar o55595 = temp__5733__auto____$1;\r\nreturn (o55595[\"js_reserved_QMARK_\"]);\r\n} else {\r\nreturn null;\r\n}\r\n} else {\r\nreturn null;\r\n}\r\n})();\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar js_reserved_fn = temp__5733__auto__;\r\nreturn (js_reserved_fn.cljs$core$IFn$_invoke$arity$1 ? js_reserved_fn.cljs$core$IFn$_invoke$arity$1(x) : js_reserved_fn.call(null,x));\r\n} else {\r\nreturn null;\r\n}\r\n});\r\ndevtools.munging.get_fn_source_safely = (function devtools$munging$get_fn_source_safely(f){\r\ntry{if(cljs.core.truth_(\"toString\" in f)){\r\nvar o__55053__auto__ = f;\r\nreturn (o__55053__auto__[\"toString\"]).call(o__55053__auto__);\r\n} else {\r\nreturn \"\";\r\n}\r\n}catch (e55601){var _ = e55601;\r\nreturn \"\";\r\n}});\r\ndevtools.munging.get_fn_fixed_arity = (function devtools$munging$get_fn_fixed_arity(f,n){\r\nreturn (f[[\"cljs$core$IFn$_invoke$arity$\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(n)].join('')]);\r\n});\r\ndevtools.munging.get_fn_variadic_arity = (function devtools$munging$get_fn_variadic_arity(f){\r\nreturn (f[\"cljs$core$IFn$_invoke$arity$variadic\"]);\r\n});\r\ndevtools.munging.get_fn_max_fixed_arity = (function devtools$munging$get_fn_max_fixed_arity(f){\r\nreturn (f[\"cljs$lang$maxFixedArity\"]);\r\n});\r\ndevtools.munging.get_type_name = (function devtools$munging$get_type_name(t){\r\nvar sb = (new goog.string.StringBuffer());\r\nvar writer = (new cljs.core.StringBufferWriter(sb));\r\ntry{var o__55053__auto___56094 = t;\r\n(o__55053__auto___56094[\"cljs$lang$ctorPrWriter\"]).call(o__55053__auto___56094,t,writer);\r\n}catch (e55706){var __56095 = e55706;\r\n}\r\nwriter.cljs$core$IWriter$_flush$arity$1(null);\r\n\r\nreturn cljs.core.str.cljs$core$IFn$_invoke$arity$1(sb);\r\n});\r\n/**\r\n * Given a character with a single digit converts it into a subscript character.\r\n *   Zero chracter maps to unicode 'SUBSCRIPT ZERO' (U+2080).\r\n */\r\ndevtools.munging.char_to_subscript = (function devtools$munging$char_to_subscript(char$){\r\nif(typeof char$ === 'string'){\r\n} else {\r\nthrow (new Error(\"Assert failed: (string? char)\"));\r\n}\r\n\r\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(char$),(1))){\r\n} else {\r\nthrow (new Error(\"Assert failed: (= (count char) 1)\"));\r\n}\r\n\r\nvar char_code = (function (){var o__55053__auto__ = (new String(char$));\r\nreturn (o__55053__auto__[\"charCodeAt\"]).call(o__55053__auto__,(0));\r\n})();\r\nvar num_code = (char_code - (48));\r\nvar subscript_code = ((8320) + num_code);\r\nvar o__55053__auto__ = String;\r\nreturn (o__55053__auto__[\"fromCharCode\"]).call(o__55053__auto__,subscript_code);\r\n});\r\n/**\r\n * Given a subscript number converts it into a string representation consisting of unicode subscript characters (digits).\r\n */\r\ndevtools.munging.make_subscript = (function devtools$munging$make_subscript(subscript){\r\nif(typeof subscript === 'number'){\r\n} else {\r\nthrow (new Error(\"Assert failed: (number? subscript)\"));\r\n}\r\n\r\nreturn clojure.string.join.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(devtools.munging.char_to_subscript,cljs.core.str.cljs$core$IFn$_invoke$arity$1(subscript)));\r\n});\r\n/**\r\n * Given a character with a single digit converts it into a superscript character.\r\n *   Zero chracter maps to unicode 'SUPERSCRIPT ZERO' (U+2070).\r\n */\r\ndevtools.munging.char_to_superscript = (function devtools$munging$char_to_superscript(char$){\r\nif(typeof char$ === 'string'){\r\n} else {\r\nthrow (new Error(\"Assert failed: (string? char)\"));\r\n}\r\n\r\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(char$),(1))){\r\n} else {\r\nthrow (new Error(\"Assert failed: (= (count char) 1)\"));\r\n}\r\n\r\nvar char_code = (function (){var o__55053__auto__ = (new String(char$));\r\nreturn (o__55053__auto__[\"charCodeAt\"]).call(o__55053__auto__,(0));\r\n})();\r\nvar num_code = (char_code - (48));\r\nvar superscript_code = (function (){var G__55728 = num_code;\r\nswitch (G__55728) {\r\ncase (1):\r\nreturn (185);\r\n\r\nbreak;\r\ncase (2):\r\nreturn (178);\r\n\r\nbreak;\r\ncase (3):\r\nreturn (179);\r\n\r\nbreak;\r\ndefault:\r\nreturn ((8304) + num_code);\r\n\r\n}\r\n})();\r\nvar o__55053__auto__ = String;\r\nreturn (o__55053__auto__[\"fromCharCode\"]).call(o__55053__auto__,superscript_code);\r\n});\r\n/**\r\n * Given a superscript number converts it into a string representation consisting of unicode superscript characters (digits).\r\n */\r\ndevtools.munging.make_superscript = (function devtools$munging$make_superscript(superscript){\r\nif(typeof superscript === 'number'){\r\n} else {\r\nthrow (new Error(\"Assert failed: (number? superscript)\"));\r\n}\r\n\r\nreturn clojure.string.join.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(devtools.munging.char_to_superscript,cljs.core.str.cljs$core$IFn$_invoke$arity$1(superscript)));\r\n});\r\n/**\r\n * Given a Javascript name answers if the name was likely generated by ClojureScript.\r\n *   We use a simple heuristic here:\r\n *  The name must contain at least two separate dollars because we assume two-segment namespaces.\r\n */\r\ndevtools.munging.cljs_fn_name_QMARK_ = (function devtools$munging$cljs_fn_name_QMARK_(munged_name){\r\nif(typeof munged_name === 'string'){\r\nreturn (!((cljs.core.re_matches(/^[^$]*\\$[^$]+\\$.*$/,munged_name) == null)));\r\n} else {\r\nreturn null;\r\n}\r\n});\r\n/**\r\n * Given a function source code parses out [name args]. Note that both strings are still munged.\r\n *   Suitable for further processing.\r\n * \r\n *   For exampe for input below the function will return [\"devtools_sample$core$hello\" \"name, unused_param\"]:\r\n * \r\n *   function devtools_sample$core$hello(name, unused_param){\r\n *  return [cljs.core.str(\"hello, \"),cljs.core.str(name),cljs.core.str(\"!\")].join('');\r\n *   }\r\n *   \r\n */\r\ndevtools.munging.parse_fn_source = (function devtools$munging$parse_fn_source(fn_source){\r\nvar temp__5733__auto__ = cljs.core.second(cljs.core.re_find(/function\\s(.*?)\\{/,fn_source));\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar meat = temp__5733__auto__;\r\nvar temp__5733__auto____$1 = cljs.core.re_find(/(.*?)\\((.*)\\)/,meat);\r\nif(cljs.core.truth_(temp__5733__auto____$1)){\r\nvar match = temp__5733__auto____$1;\r\nreturn cljs.core.rest(match);\r\n} else {\r\nreturn null;\r\n}\r\n} else {\r\nreturn null;\r\n}\r\n});\r\ndevtools.munging.trivial_fn_source_QMARK_ = (function devtools$munging$trivial_fn_source_QMARK_(fn_source){\r\nif(typeof fn_source === 'string'){\r\n} else {\r\nthrow (new Error(\"Assert failed: (string? fn-source)\"));\r\n}\r\n\r\nreturn (((!((cljs.core.re_matches(/function\\s*\\(\\s*\\)\\s*\\{\\s*\\}\\s*/,fn_source) == null)))) || ((!((cljs.core.re_matches(/function.*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*/,fn_source) == null)))) || ((!((cljs.core.re_matches(/function anonymous\\(\\s*\\)\\s*\\{\\s*\\}/,fn_source) == null)))));\r\n});\r\n/**\r\n * Given a Javascript function object returns true if the function looks like a ClojureScript function.\r\n * \r\n *   Uses various heuristics:\r\n *  1. must be fn? (is javascript function or satisfies Fn and IFn protocols)\r\n *  2. and name must be cljs-fn-name? (name can come from f.name or parsed out of function source)\r\n *  3. or if anonymous function, must be non-trivial\r\n */\r\ndevtools.munging.cljs_fn_QMARK_ = (function devtools$munging$cljs_fn_QMARK_(f){\r\nif(cljs.core.truth_((function (){try{return cljs.core.fn_QMARK_(f);\r\n}catch (e55785){var _e__55067__auto__ = e55785;\r\nreturn false;\r\n}})())){\r\nvar name = (f[cljs.core.name]);\r\nif((!(cljs.core.empty_QMARK_(name)))){\r\nreturn devtools.munging.cljs_fn_name_QMARK_(name);\r\n} else {\r\nvar fn_source = devtools.munging.get_fn_source_safely(f);\r\nvar vec__55787 = devtools.munging.parse_fn_source(fn_source);\r\nvar name__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55787,(0),null);\r\nif((!(cljs.core.empty_QMARK_(name__$1)))){\r\nreturn devtools.munging.cljs_fn_name_QMARK_(name__$1);\r\n} else {\r\nreturn (!(devtools.munging.trivial_fn_source_QMARK_(fn_source)));\r\n}\r\n}\r\n} else {\r\nreturn null;\r\n}\r\n});\r\n/**\r\n * Standard cljs.core/demunge is too agresive in replacing dollars.\r\n *   This wrapper function works around it by leaving dollars intact.\r\n */\r\ndevtools.munging.dollar_preserving_demunge = (function devtools$munging$dollar_preserving_demunge(munged_name){\r\nreturn clojure.string.replace(cljs.core.demunge(clojure.string.replace(munged_name,\"$\",devtools.munging.dollar_replacement)),devtools.munging.dollar_replacement,\"$\");\r\n});\r\ndevtools.munging.revert_reserved = (function devtools$munging$revert_reserved(s){\r\nvar or__4120__auto__ = (function (){var temp__5733__auto__ = cljs.core.re_matches(/(.*)\\$/,s);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar m = temp__5733__auto__;\r\nif(cljs.core.truth_(devtools.munging.js_reserved_QMARK_(cljs.core.second(m)))){\r\nreturn cljs.core.second(m);\r\n} else {\r\nreturn null;\r\n}\r\n} else {\r\nreturn null;\r\n}\r\n})();\r\nif(cljs.core.truth_(or__4120__auto__)){\r\nreturn or__4120__auto__;\r\n} else {\r\nreturn s;\r\n}\r\n});\r\ndevtools.munging.reserved_aware_demunge = (function devtools$munging$reserved_aware_demunge(munged_name){\r\nreturn devtools.munging.revert_reserved(devtools.munging.dollar_preserving_demunge(munged_name));\r\n});\r\ndevtools.munging.proper_demunge = (function devtools$munging$proper_demunge(munged_name){\r\nreturn devtools.munging.reserved_aware_demunge(munged_name);\r\n});\r\ndevtools.munging.proper_arg_demunge = (function devtools$munging$proper_arg_demunge(munged_arg_name){\r\nreturn clojure.string.replace(devtools.munging.proper_demunge(munged_arg_name),/^-(.*)$/,\"_$1\");\r\n});\r\ndevtools.munging.proper_ns_demunge = (function devtools$munging$proper_ns_demunge(munged_ns_name){\r\nreturn clojure.string.replace(devtools.munging.proper_demunge(munged_ns_name),\"$\",\".\");\r\n});\r\ndevtools.munging.ns_exists_QMARK_ = (function devtools$munging$ns_exists_QMARK_(ns_module_name){\r\nif(typeof ns_module_name === 'string'){\r\n} else {\r\nthrow (new Error(\"Assert failed: (string? ns-module-name)\"));\r\n}\r\n\r\nvar temp__5733__auto__ = (function (){var temp__5733__auto__ = ((devtools.munging.get_global_scope.cljs$core$IFn$_invoke$arity$0 ? devtools.munging.get_global_scope.cljs$core$IFn$_invoke$arity$0() : devtools.munging.get_global_scope.call(null))[\"goog\"]);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar o55807 = temp__5733__auto__;\r\nvar temp__5733__auto____$1 = (o55807[\"dependencies_\"]);\r\nif(cljs.core.truth_(temp__5733__auto____$1)){\r\nvar o55808 = temp__5733__auto____$1;\r\nreturn (o55808[\"nameToPath\"]);\r\n} else {\r\nreturn null;\r\n}\r\n} else {\r\nreturn null;\r\n}\r\n})();\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar goog_namespaces = temp__5733__auto__;\r\nreturn (!(((goog_namespaces[ns_module_name]) == null)));\r\n} else {\r\nreturn null;\r\n}\r\n});\r\n/**\r\n * Given a name broken into namespace parts returns [detected-ns remaining-parts],\r\n *   where detected-ns is a string representing longest detected existing namespace and\r\n *   remaining-parts is a vector of remaing input parts not included in the detected-ns concatenation.\r\n * \r\n *   For given input [\"cljs\" \"core\" \"first\"] returns [\"cljs.core\" [\"first\"]] (asumming cljs.core exists)\r\n */\r\ndevtools.munging.detect_namespace_prefix = (function devtools$munging$detect_namespace_prefix(var_args){\r\nvar args__4736__auto__ = [];\r\nvar len__4730__auto___56112 = arguments.length;\r\nvar i__4731__auto___56113 = (0);\r\nwhile(true){\r\nif((i__4731__auto___56113 < len__4730__auto___56112)){\r\nargs__4736__auto__.push((arguments[i__4731__auto___56113]));\r\n\r\nvar G__56114 = (i__4731__auto___56113 + (1));\r\ni__4731__auto___56113 = G__56114;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\r\nreturn devtools.munging.detect_namespace_prefix.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\r\n});\r\n\r\n(devtools.munging.detect_namespace_prefix.cljs$core$IFn$_invoke$arity$variadic = (function (tokens,p__55825){\r\nvar vec__55827 = p__55825;\r\nvar ns_detector = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55827,(0),null);\r\nvar effective_detector = (function (){var or__4120__auto__ = ns_detector;\r\nif(cljs.core.truth_(or__4120__auto__)){\r\nreturn or__4120__auto__;\r\n} else {\r\nreturn devtools.munging.ns_exists_QMARK_;\r\n}\r\n})();\r\nvar name_tokens = cljs.core.PersistentVector.EMPTY;\r\nvar remaining_tokens = tokens;\r\nwhile(true){\r\nif(cljs.core.empty_QMARK_(remaining_tokens)){\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",name_tokens], null);\r\n} else {\r\nvar ns_name = clojure.string.join.cljs$core$IFn$_invoke$arity$2(\".\",remaining_tokens);\r\nif(cljs.core.truth_((effective_detector.cljs$core$IFn$_invoke$arity$1 ? effective_detector.cljs$core$IFn$_invoke$arity$1(ns_name) : effective_detector.call(null,ns_name)))){\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns_name,name_tokens], null);\r\n} else {\r\nvar G__56115 = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.last(remaining_tokens)], null),name_tokens);\r\nvar G__56116 = cljs.core.butlast(remaining_tokens);\r\nname_tokens = G__56115;\r\nremaining_tokens = G__56116;\r\ncontinue;\r\n}\r\n}\r\nbreak;\r\n}\r\n}));\r\n\r\n(devtools.munging.detect_namespace_prefix.cljs$lang$maxFixedArity = (1));\r\n\r\n/** @this {Function} */\r\n(devtools.munging.detect_namespace_prefix.cljs$lang$applyTo = (function (seq55819){\r\nvar G__55820 = cljs.core.first(seq55819);\r\nvar seq55819__$1 = cljs.core.next(seq55819);\r\nvar self__4717__auto__ = this;\r\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__55820,seq55819__$1);\r\n}));\r\n\r\ndevtools.munging.normalize_arity = (function devtools$munging$normalize_arity(arity_tokens){\r\nif((!(cljs.core.empty_QMARK_(arity_tokens)))){\r\nvar arity = cljs.core.first(arity_tokens);\r\nvar G__55841 = arity;\r\nswitch (G__55841) {\r\ncase \"variadic\":\r\nreturn arity;\r\n\r\nbreak;\r\ndefault:\r\nreturn parseInt(arity,(10));\r\n\r\n}\r\n} else {\r\nreturn null;\r\n}\r\n});\r\ndevtools.munging.strip_arity = (function devtools$munging$strip_arity(tokens){\r\nvar vec__55844 = cljs.core.split_with((function (p1__55842_SHARP_){\r\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__55842_SHARP_,\"arity\");\r\n}),tokens);\r\nvar prefix_tokens = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55844,(0),null);\r\nvar arity_tokens = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55844,(1),null);\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [prefix_tokens,devtools.munging.normalize_arity(cljs.core.rest(arity_tokens))], null);\r\n});\r\ndevtools.munging.parse_protocol = (function devtools$munging$parse_protocol(tokens,detector){\r\nvar remaining_tokens = tokens;\r\nvar name_tokens = cljs.core.PersistentVector.EMPTY;\r\nwhile(true){\r\nif(cljs.core.empty_QMARK_(remaining_tokens)){\r\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [name_tokens], null);\r\n} else {\r\nvar vec__55913 = devtools.munging.detect_namespace_prefix.cljs$core$IFn$_invoke$arity$variadic(remaining_tokens,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([detector], 0));\r\nvar protocol_ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55913,(0),null);\r\nvar name_and_method_tokens = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55913,(1),null);\r\nif(cljs.core.empty_QMARK_(protocol_ns)){\r\nvar G__56120 = cljs.core.rest(remaining_tokens);\r\nvar G__56121 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(name_tokens,cljs.core.first(remaining_tokens));\r\nremaining_tokens = G__56120;\r\nname_tokens = G__56121;\r\ncontinue;\r\n} else {\r\nreturn new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [name_tokens,protocol_ns,cljs.core.first(name_and_method_tokens),cljs.core.rest(name_and_method_tokens)], null);\r\n}\r\n}\r\nbreak;\r\n}\r\n});\r\n/**\r\n * Given a munged-name from Javascript lands attempts to break it into:\r\n *   [fn-ns fn-name protocol-ns protocol-name protocol-method arity].\r\n * \r\n *   Protocol and arity elements are optional. Function elements are always present or \"\".\r\n * \r\n *   examples for input:\r\n *  cljs$core$rest => ['cljs.core', 'rest']\r\n *  cljs.core.reduce$cljs$core$IFn$_invoke$arity$3 => ['cljs.core' 'reduce' 'cljs.core' 'IFn' '_invoke' 3]\r\n */\r\ndevtools.munging.break_munged_name = (function devtools$munging$break_munged_name(var_args){\r\nvar G__55923 = arguments.length;\r\nswitch (G__55923) {\r\ncase 1:\r\nreturn devtools.munging.break_munged_name.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ncase 2:\r\nreturn devtools.munging.break_munged_name.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(devtools.munging.break_munged_name.cljs$core$IFn$_invoke$arity$1 = (function (munged_name){\r\nreturn devtools.munging.break_munged_name.cljs$core$IFn$_invoke$arity$2(munged_name,null);\r\n}));\r\n\r\n(devtools.munging.break_munged_name.cljs$core$IFn$_invoke$arity$2 = (function (munged_name,ns_detector){\r\nif(cljs.core.empty_QMARK_(munged_name)){\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",\"\"], null);\r\n} else {\r\nvar effective_detector = (function (){var or__4120__auto__ = ns_detector;\r\nif(cljs.core.truth_(or__4120__auto__)){\r\nreturn or__4120__auto__;\r\n} else {\r\nreturn devtools.munging.ns_exists_QMARK_;\r\n}\r\n})();\r\nvar tokens = cljs.core.vec(munged_name.split(/[$.]/));\r\nvar vec__55931 = devtools.munging.strip_arity(tokens);\r\nvar tokens__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55931,(0),null);\r\nvar arity = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55931,(1),null);\r\nvar vec__55934 = devtools.munging.detect_namespace_prefix.cljs$core$IFn$_invoke$arity$variadic(tokens__$1,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([effective_detector], 0));\r\nvar fn_ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55934,(0),null);\r\nvar tokens__$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55934,(1),null);\r\nvar vec__55937 = devtools.munging.parse_protocol(tokens__$2,effective_detector);\r\nvar fn_name_tokens = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55937,(0),null);\r\nvar protocol_ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55937,(1),null);\r\nvar protocol_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55937,(2),null);\r\nvar protocol_method_tokens = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55937,(3),null);\r\nvar fn_name = clojure.string.join.cljs$core$IFn$_invoke$arity$2(\"$\",fn_name_tokens);\r\nvar protocol_method = (cljs.core.truth_(protocol_method_tokens)?clojure.string.join.cljs$core$IFn$_invoke$arity$2(\"$\",protocol_method_tokens):null);\r\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [fn_ns,fn_name,protocol_ns,protocol_name,protocol_method,arity], null);\r\n}\r\n}));\r\n\r\n(devtools.munging.break_munged_name.cljs$lang$maxFixedArity = 2);\r\n\r\n/**\r\n * Given a munged-name from Javascript lands attempts to break it into a namespace part and remaining short name.\r\n *   Then applies appropriate demunging on them and returns ClojureScript versions of the names.\r\n */\r\ndevtools.munging.break_and_demunge_name = (function devtools$munging$break_and_demunge_name(var_args){\r\nvar G__55942 = arguments.length;\r\nswitch (G__55942) {\r\ncase 1:\r\nreturn devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\r\n\r\nbreak;\r\ncase 2:\r\nreturn devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\r\n\r\nbreak;\r\ndefault:\r\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\r\n\r\n}\r\n});\r\n\r\n(devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$1 = (function (munged_name){\r\nreturn devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$2(munged_name,null);\r\n}));\r\n\r\n(devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$2 = (function (munged_name,ns_detector){\r\nvar result = devtools.munging.break_munged_name.cljs$core$IFn$_invoke$arity$2(munged_name,ns_detector);\r\nvar vec__55944 = result;\r\nvar munged_ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55944,(0),null);\r\nvar munged_name__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55944,(1),null);\r\nvar munged_protocol_ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55944,(2),null);\r\nvar munged_protocol_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55944,(3),null);\r\nvar munged_protocol_method = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55944,(4),null);\r\nvar arity = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55944,(5),null);\r\nreturn new cljs.core.PersistentVector(null, 6, 5, cljs.core.PersistentVector.EMPTY_NODE, [devtools.munging.proper_ns_demunge(munged_ns),devtools.munging.proper_demunge(munged_name__$1),(cljs.core.truth_(munged_protocol_ns)?devtools.munging.proper_ns_demunge(munged_protocol_ns):null),(cljs.core.truth_(munged_protocol_name)?devtools.munging.proper_demunge(munged_protocol_name):null),(cljs.core.truth_(munged_protocol_method)?devtools.munging.proper_demunge(munged_protocol_method):null),arity], null);\r\n}));\r\n\r\n(devtools.munging.break_and_demunge_name.cljs$lang$maxFixedArity = 2);\r\n\r\n/**\r\n * Given function source code tries to retrieve [ns name & args] on best effort basis, where\r\n *   ns is demunged namespace part of the function name (or \"\" if namespace cannot be detected)\r\n *   name is demunged short name (or \"\" if function is anonymous or name cannot be retrieved)\r\n *   args is optional number of demunged argument names.\r\n * \r\n *   Please note that this function always returns a vector with something. In worst cases [\"\" \"\"].\r\n *   \r\n */\r\ndevtools.munging.parse_fn_source_info = (function devtools$munging$parse_fn_source_info(fn_source){\r\nvar temp__5733__auto__ = devtools.munging.parse_fn_source(fn_source);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar vec__55954 = temp__5733__auto__;\r\nvar munged_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55954,(0),null);\r\nvar args = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55954,(1),null);\r\nvar vec__55957 = devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$1(munged_name);\r\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55957,(0),null);\r\nvar name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55957,(1),null);\r\nvar demunged_args = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.comp.cljs$core$IFn$_invoke$arity$2(devtools.munging.proper_arg_demunge,clojure.string.trim),clojure.string.split.cljs$core$IFn$_invoke$arity$2(args,/,/));\r\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns,name], null),demunged_args);\r\n} else {\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",\"\"], null);\r\n}\r\n});\r\n/**\r\n * Given Javascript function object tries to retrieve [ns name & args] as in parse-fn-source-info (on best effort basis).\r\n */\r\ndevtools.munging.parse_fn_info = (function devtools$munging$parse_fn_info(f){\r\nvar fn_source = devtools.munging.get_fn_source_safely(f);\r\nreturn devtools.munging.parse_fn_source_info(fn_source);\r\n});\r\n/**\r\n * Given a Javascript function object tries to retrieve [ns name & args] as in parse-fn-info (on best effort basis).\r\n * \r\n *   The difference from parse-fn-info is that this function prefers to read args from arities if available.\r\n *   It recurses arbitrary deep following IFn protocol leads.\r\n * \r\n *   If we hit multi-arity situation in leaf, we don't attempt to list arguments and return ::multi-arity placeholder instead.\r\n * \r\n *   The reason for reading arities is that it gives more accurate parameter names in some cases.\r\n *   We observed that variadic functions don't always contain original parameter names, but individual IFn arity functions do.\r\n */\r\ndevtools.munging.parse_fn_info_deep = (function devtools$munging$parse_fn_info_deep(f){\r\nvar fn_info = devtools.munging.parse_fn_info(f);\r\nvar arities = (devtools.munging.collect_fn_arities.cljs$core$IFn$_invoke$arity$1 ? devtools.munging.collect_fn_arities.cljs$core$IFn$_invoke$arity$1(f) : devtools.munging.collect_fn_arities.call(null,f));\r\nif((!((arities == null)))){\r\nif((cljs.core.count(arities) > (1))){\r\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.take.cljs$core$IFn$_invoke$arity$2((2),fn_info),new cljs.core.Keyword(\"devtools.munging\",\"multi-arity\",\"devtools.munging/multi-arity\",-2011705837));\r\n} else {\r\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.take.cljs$core$IFn$_invoke$arity$2((2),fn_info),cljs.core.drop.cljs$core$IFn$_invoke$arity$2((2),(function (){var G__55972 = cljs.core.second(cljs.core.first(arities));\r\nreturn (devtools.munging.parse_fn_info_deep.cljs$core$IFn$_invoke$arity$1 ? devtools.munging.parse_fn_info_deep.cljs$core$IFn$_invoke$arity$1(G__55972) : devtools.munging.parse_fn_info_deep.call(null,G__55972));\r\n})()));\r\n}\r\n} else {\r\nreturn fn_info;\r\n}\r\n});\r\n/**\r\n * Given a demunged ClojureScript parameter name. Tries to detect human readable part and returns the index where it ends.\r\n *   Returns nil if no prefix can be detected.\r\n * \r\n *   The idea is to convert macro-generated parameters and other generated names to more friendly names.\r\n *   We observed that param names generated by gensym have prefix followed by big numbers.\r\n *   Other generated names contain two dashes after prefix (originally probably using underscores).\r\n */\r\ndevtools.munging.find_index_of_human_prefix = (function devtools$munging$find_index_of_human_prefix(name){\r\nvar sep_start = name.indexOf(\"--\");\r\nvar num_prefix = cljs.core.count(cljs.core.second(cljs.core.re_find(/(.*?)\\d{2,}/,name)));\r\nvar finds = cljs.core.filter.cljs$core$IFn$_invoke$arity$2(cljs.core.pos_QMARK_,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [sep_start,num_prefix], null));\r\nif((!(cljs.core.empty_QMARK_(finds)))){\r\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.min,finds);\r\n} else {\r\nreturn null;\r\n}\r\n});\r\n/**\r\n * Given a name and intermediate state. Convert name to a human readable version by keeping human readable prefix with\r\n *   optional subscribt postfix and store it in ::result. Subscript number is picked based on state. State keeps track of\r\n *   previously assigned subscripts. Returns a new state.\r\n */\r\ndevtools.munging.humanize_name = (function devtools$munging$humanize_name(state,name){\r\nvar index = devtools.munging.find_index_of_human_prefix(name);\r\nvar prefix = (((index > (0)))?name.substring((0),index):name);\r\nvar temp__5733__auto__ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(state,prefix);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar subscript = temp__5733__auto__;\r\nreturn cljs.core.update.cljs$core$IFn$_invoke$arity$3(cljs.core.update.cljs$core$IFn$_invoke$arity$4(state,new cljs.core.Keyword(\"devtools.munging\",\"result\",\"devtools.munging/result\",1642759166),cljs.core.conj,[cljs.core.str.cljs$core$IFn$_invoke$arity$1(prefix),devtools.munging.make_subscript(subscript)].join('')),prefix,cljs.core.inc);\r\n} else {\r\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(cljs.core.update.cljs$core$IFn$_invoke$arity$4(state,new cljs.core.Keyword(\"devtools.munging\",\"result\",\"devtools.munging/result\",1642759166),cljs.core.conj,prefix),prefix,(2));\r\n}\r\n});\r\n/**\r\n * Given a list of names, returns a list of human-readable versions of those names.\r\n *   It detects human-readable prefix using a simple heuristics. When names repeat it assigns simple subscripts starting with 2.\r\n *   Subscripts are assigned left-to-right.\r\n * \r\n *   Given [\"p--a\" \"p--b\" \"x\" \"p--c\"] returns [\"p\" \"p₂\" \"x\" \"p₃\"]\r\n */\r\ndevtools.munging.humanize_names = (function devtools$munging$humanize_names(names){\r\nreturn cljs.core.with_meta(new cljs.core.Keyword(\"devtools.munging\",\"result\",\"devtools.munging/result\",1642759166).cljs$core$IFn$_invoke$arity$1(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(devtools.munging.humanize_name,new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"devtools.munging\",\"result\",\"devtools.munging/result\",1642759166),cljs.core.PersistentVector.EMPTY], null),names)),cljs.core.meta(names));\r\n});\r\ndevtools.munging.collect_fn_fixed_arities = (function devtools$munging$collect_fn_fixed_arities(f,max_arity){\r\nvar arity = (0);\r\nvar collection = cljs.core.PersistentArrayMap.EMPTY;\r\nwhile(true){\r\nif((arity > max_arity)){\r\nreturn collection;\r\n} else {\r\nvar G__56146 = (arity + (1));\r\nvar G__56147 = (function (){var temp__5733__auto__ = devtools.munging.get_fn_fixed_arity(f,arity);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar arity_fn = temp__5733__auto__;\r\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(collection,arity,arity_fn);\r\n} else {\r\nreturn collection;\r\n}\r\n})();\r\narity = G__56146;\r\ncollection = G__56147;\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\n});\r\ndevtools.munging.collect_fn_variadic_arities = (function devtools$munging$collect_fn_variadic_arities(f){\r\nvar temp__5733__auto__ = devtools.munging.get_fn_variadic_arity(f);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar variadic_arity = temp__5733__auto__;\r\nreturn new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908),variadic_arity], null);\r\n} else {\r\nreturn null;\r\n}\r\n});\r\ndevtools.munging.review_arity = (function devtools$munging$review_arity(p__55984){\r\nvar vec__55985 = p__55984;\r\nvar arity = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55985,(0),null);\r\nvar arity_fn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__55985,(1),null);\r\nvar sub_arities = (devtools.munging.collect_fn_arities.cljs$core$IFn$_invoke$arity$1 ? devtools.munging.collect_fn_arities.cljs$core$IFn$_invoke$arity$1(arity_fn) : devtools.munging.collect_fn_arities.call(null,arity_fn));\r\nif(cljs.core.truth_(new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908).cljs$core$IFn$_invoke$arity$1(sub_arities))){\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908),arity_fn], null);\r\n} else {\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [arity,arity_fn], null);\r\n}\r\n});\r\n/**\r\n * Some arities can be marked as fixed arity but in fact point to a variadic-arity function. We want to detect this case\r\n *   and turn such improperly categorized arities to ::variadic.\r\n */\r\ndevtools.munging.review_arities = (function devtools$munging$review_arities(arities){\r\nif(cljs.core.truth_(new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908).cljs$core$IFn$_invoke$arity$1(arities))){\r\nreturn arities;\r\n} else {\r\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$2(devtools.munging.review_arity,arities));\r\n}\r\n});\r\n/**\r\n * Given a Javascript function object, tries to inspect known arity properties generated by ClojureScript compiler and\r\n *   collects all available arity functions into a map. Arities are keyed by arity count and variadic arity gets ::variadic key.\r\n */\r\ndevtools.munging.collect_fn_arities = (function devtools$munging$collect_fn_arities(f){\r\nvar max_fixed_arity = devtools.munging.get_fn_max_fixed_arity(f);\r\nvar fixed_arities = devtools.munging.collect_fn_fixed_arities(f,(function (){var or__4120__auto__ = max_fixed_arity;\r\nif(cljs.core.truth_(or__4120__auto__)){\r\nreturn or__4120__auto__;\r\n} else {\r\nreturn devtools.munging.max_fixed_arity_to_scan;\r\n}\r\n})());\r\nvar variadic_arities = devtools.munging.collect_fn_variadic_arities(f);\r\nvar arities = devtools.munging.review_arities(cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([fixed_arities,variadic_arities], 0)));\r\nif((!(cljs.core.empty_QMARK_(arities)))){\r\nreturn arities;\r\n} else {\r\nreturn null;\r\n}\r\n});\r\n/**\r\n * ::variadic goes last, other keywords compare by name.\r\n */\r\ndevtools.munging.arity_keywords_comparator = (function devtools$munging$arity_keywords_comparator(x,y){\r\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908),x)){\r\nreturn (1);\r\n} else {\r\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908),y)){\r\nreturn (-1);\r\n} else {\r\nreturn cljs.core.compare(cljs.core.name(x),cljs.core.name(y));\r\n\r\n}\r\n}\r\n});\r\n/**\r\n * numbers go first (ordered), then keywords (ordered by name), and then ::variadic sticks last\r\n */\r\ndevtools.munging.arities_key_comparator = (function devtools$munging$arities_key_comparator(x,y){\r\nvar kx_QMARK_ = (x instanceof cljs.core.Keyword);\r\nvar ky_QMARK_ = (y instanceof cljs.core.Keyword);\r\nif(((kx_QMARK_) && (ky_QMARK_))){\r\nreturn devtools.munging.arity_keywords_comparator(x,y);\r\n} else {\r\nif(kx_QMARK_){\r\nreturn (1);\r\n} else {\r\nif(ky_QMARK_){\r\nreturn (-1);\r\n} else {\r\nreturn cljs.core.compare(x,y);\r\n\r\n}\r\n}\r\n}\r\n});\r\ndevtools.munging.arities_to_args_lists_STAR_ = (function devtools$munging$arities_to_args_lists_STAR_(arities){\r\nvar sorted_keys = cljs.core.sort.cljs$core$IFn$_invoke$arity$2(devtools.munging.arities_key_comparator,cljs.core.keys(arities));\r\nvar sorted_fns = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__55995_SHARP_){\r\nreturn cljs.core.get.cljs$core$IFn$_invoke$arity$2(arities,p1__55995_SHARP_);\r\n}),sorted_keys);\r\nvar sorted_infos = cljs.core.map.cljs$core$IFn$_invoke$arity$2(devtools.munging.parse_fn_info_deep,sorted_fns);\r\nvar sorted_args_lists = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__55996_SHARP_){\r\nreturn cljs.core.drop.cljs$core$IFn$_invoke$arity$2((2),p1__55996_SHARP_);\r\n}),sorted_infos);\r\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.last(sorted_keys),new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908))){\r\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(cljs.core.butlast(sorted_args_lists),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4(cljs.core.last(sorted_args_lists),cljs.core.assoc,new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908),true)], null));\r\n} else {\r\nreturn sorted_args_lists;\r\n}\r\n});\r\n/**\r\n * Given a map of arity functions. Tries to parse individual functions and prepare an arguments list for each arity.\r\n *   Returned list of arguments list is sorted by arity count, variadic arity goes last if available.\r\n * \r\n *   The function also optionally humanizes argument names in each arguments list if requested.\r\n */\r\ndevtools.munging.arities_to_args_lists = (function devtools$munging$arities_to_args_lists(var_args){\r\nvar args__4736__auto__ = [];\r\nvar len__4730__auto___56155 = arguments.length;\r\nvar i__4731__auto___56156 = (0);\r\nwhile(true){\r\nif((i__4731__auto___56156 < len__4730__auto___56155)){\r\nargs__4736__auto__.push((arguments[i__4731__auto___56156]));\r\n\r\nvar G__56157 = (i__4731__auto___56156 + (1));\r\ni__4731__auto___56156 = G__56157;\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nvar argseq__4737__auto__ = ((((1) < args__4736__auto__.length))?(new cljs.core.IndexedSeq(args__4736__auto__.slice((1)),(0),null)):null);\r\nreturn devtools.munging.arities_to_args_lists.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4737__auto__);\r\n});\r\n\r\n(devtools.munging.arities_to_args_lists.cljs$core$IFn$_invoke$arity$variadic = (function (arities,p__56006){\r\nvar vec__56007 = p__56006;\r\nvar humanize_QMARK_ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56007,(0),null);\r\nvar args_lists = devtools.munging.arities_to_args_lists_STAR_(arities);\r\nif(cljs.core.truth_(humanize_QMARK_)){\r\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(devtools.munging.humanize_names,args_lists);\r\n} else {\r\nreturn args_lists;\r\n}\r\n}));\r\n\r\n(devtools.munging.arities_to_args_lists.cljs$lang$maxFixedArity = (1));\r\n\r\n/** @this {Function} */\r\n(devtools.munging.arities_to_args_lists.cljs$lang$applyTo = (function (seq55998){\r\nvar G__55999 = cljs.core.first(seq55998);\r\nvar seq55998__$1 = cljs.core.next(seq55998);\r\nvar self__4717__auto__ = this;\r\nreturn self__4717__auto__.cljs$core$IFn$_invoke$arity$variadic(G__55999,seq55998__$1);\r\n}));\r\n\r\n/**\r\n * Converts a list of arguments lists into a list of strings suitable for UI presentation.\r\n */\r\ndevtools.munging.args_lists_to_strings = (function devtools$munging$args_lists_to_strings(args_lists,spacer_symbol,multi_arity_symbol,rest_symbol){\r\nvar string_mapper = (function (arg){\r\nvar G__56017 = arg;\r\nvar G__56017__$1 = (((G__56017 instanceof cljs.core.Keyword))?G__56017.fqn:null);\r\nswitch (G__56017__$1) {\r\ncase \"devtools.munging/multi-arity\":\r\nreturn multi_arity_symbol;\r\n\r\nbreak;\r\ndefault:\r\nreturn arg;\r\n\r\n}\r\n});\r\nvar printer = (function (args_list){\r\nvar variadic_QMARK_ = new cljs.core.Keyword(\"devtools.munging\",\"variadic\",\"devtools.munging/variadic\",1596047908).cljs$core$IFn$_invoke$arity$1(cljs.core.meta(args_list));\r\nvar args_strings = cljs.core.map.cljs$core$IFn$_invoke$arity$2(string_mapper,args_list);\r\nreturn [clojure.string.join.cljs$core$IFn$_invoke$arity$2(spacer_symbol,cljs.core.butlast(args_strings)),cljs.core.str.cljs$core$IFn$_invoke$arity$1((cljs.core.truth_(variadic_QMARK_)?rest_symbol:spacer_symbol)),cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.last(args_strings))].join('');\r\n});\r\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(clojure.string.trim,cljs.core.map.cljs$core$IFn$_invoke$arity$2(printer,args_lists));\r\n});\r\ndevtools.munging.extract_arities = (function devtools$munging$extract_arities(f,humanize_QMARK_,spacer_symbol,multi_arity_symbol,rest_symbol){\r\nreturn devtools.munging.args_lists_to_strings(devtools.munging.arities_to_args_lists.cljs$core$IFn$_invoke$arity$variadic((function (){var or__4120__auto__ = devtools.munging.collect_fn_arities(f);\r\nif(cljs.core.truth_(or__4120__auto__)){\r\nreturn or__4120__auto__;\r\n} else {\r\nreturn new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(null,\"naked\",\"naked\",373474222),f], null);\r\n}\r\n})(),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([humanize_QMARK_], 0)),spacer_symbol,multi_arity_symbol,rest_symbol);\r\n});\r\ndevtools.munging.common_protocol_QMARK_ = (function devtools$munging$common_protocol_QMARK_(protocol_ns,protocol_name){\r\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(protocol_ns,\"cljs.core\")) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(protocol_name,\"IFn\")));\r\n});\r\ndevtools.munging.present_fn_part = (function devtools$munging$present_fn_part(fn_ns,fn_name,include_ns_QMARK_){\r\nreturn [(cljs.core.truth_((function (){var and__4109__auto__ = include_ns_QMARK_;\r\nif(cljs.core.truth_(and__4109__auto__)){\r\nreturn (!(cljs.core.empty_QMARK_(fn_ns)));\r\n} else {\r\nreturn and__4109__auto__;\r\n}\r\n})())?[cljs.core.str.cljs$core$IFn$_invoke$arity$1(fn_ns),\"/\"].join(''):null),cljs.core.str.cljs$core$IFn$_invoke$arity$1(fn_name)].join('');\r\n});\r\ndevtools.munging.present_protocol_part = (function devtools$munging$present_protocol_part(protocol_ns,protocol_name,protocol_method,include_protocol_ns_QMARK_){\r\nreturn [cljs.core.str.cljs$core$IFn$_invoke$arity$1((cljs.core.truth_(include_protocol_ns_QMARK_)?protocol_ns:null)),(((!(cljs.core.empty_QMARK_(protocol_name))))?[(cljs.core.truth_(include_protocol_ns_QMARK_)?\".\":null),cljs.core.str.cljs$core$IFn$_invoke$arity$1(protocol_name)].join(''):null),(((!(cljs.core.empty_QMARK_(protocol_method))))?[(cljs.core.truth_((function (){var or__4120__auto__ = include_protocol_ns_QMARK_;\r\nif(cljs.core.truth_(or__4120__auto__)){\r\nreturn or__4120__auto__;\r\n} else {\r\nreturn (!(cljs.core.empty_QMARK_(protocol_name)));\r\n}\r\n})())?\":\":null),cljs.core.str.cljs$core$IFn$_invoke$arity$1(protocol_method)].join(''):null)].join('');\r\n});\r\n/**\r\n * Given javascript function name tries to present it as plain string for display in UI on best effort basis.\r\n */\r\ndevtools.munging.present_function_name = (function devtools$munging$present_function_name(munged_name,options){\r\nvar map__56033 = options;\r\nvar map__56033__$1 = (((((!((map__56033 == null))))?(((((map__56033.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__56033.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__56033):map__56033);\r\nvar include_ns_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56033__$1,new cljs.core.Keyword(null,\"include-ns?\",\"include-ns?\",-341372810));\r\nvar include_protocol_ns_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56033__$1,new cljs.core.Keyword(null,\"include-protocol-ns?\",\"include-protocol-ns?\",989250951));\r\nvar silence_common_protocols_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56033__$1,new cljs.core.Keyword(null,\"silence-common-protocols?\",\"silence-common-protocols?\",2012431893));\r\nvar ns_detector = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__56033__$1,new cljs.core.Keyword(null,\"ns-detector\",\"ns-detector\",-2041592760));\r\nvar vec__56034 = devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$2(munged_name,ns_detector);\r\nvar fn_ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56034,(0),null);\r\nvar fn_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56034,(1),null);\r\nvar protocol_ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56034,(2),null);\r\nvar protocol_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56034,(3),null);\r\nvar protocol_method = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56034,(4),null);\r\nvar arity = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56034,(5),null);\r\nvar arity_str = (((!((arity == null))))?((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(arity,\"variadic\"))?\"\\u207F\":devtools.munging.make_superscript(arity)):null);\r\nif(cljs.core.empty_QMARK_(fn_name)){\r\nreturn munged_name;\r\n} else {\r\nvar fn_part = devtools.munging.present_fn_part(fn_ns,fn_name,include_ns_QMARK_);\r\nvar protocol_part = (cljs.core.truth_((function (){var and__4109__auto__ = protocol_ns;\r\nif(cljs.core.truth_(and__4109__auto__)){\r\nreturn cljs.core.not((function (){var and__4109__auto____$1 = silence_common_protocols_QMARK_;\r\nif(cljs.core.truth_(and__4109__auto____$1)){\r\nreturn devtools.munging.common_protocol_QMARK_(protocol_ns,protocol_name);\r\n} else {\r\nreturn and__4109__auto____$1;\r\n}\r\n})());\r\n} else {\r\nreturn and__4109__auto__;\r\n}\r\n})())?devtools.munging.present_protocol_part(protocol_ns,protocol_name,protocol_method,include_protocol_ns_QMARK_):null);\r\nreturn [(function (){var or__4120__auto__ = protocol_part;\r\nif(cljs.core.truth_(or__4120__auto__)){\r\nreturn or__4120__auto__;\r\n} else {\r\nreturn fn_part;\r\n}\r\n})(),arity_str,(cljs.core.truth_(protocol_part)?[\" (\",fn_part,\")\"].join(''):null)].join('');\r\n}\r\n});\r\ndevtools.munging.get_basis = (function devtools$munging$get_basis(f){\r\nvar o__55053__auto__ = f;\r\nreturn (o__55053__auto__[\"getBasis\"]).call(o__55053__auto__);\r\n});\r\n/**\r\n * Given a Javascript constructor function tries to retrieve [ns name basis]. Returns nil if not a cljs type.\r\n */\r\ndevtools.munging.parse_constructor_info = (function devtools$munging$parse_constructor_info(f){\r\nif(cljs.core.truth_((function (){var and__4109__auto__ = goog.isObject(f);\r\nif(cljs.core.truth_(and__4109__auto__)){\r\nreturn f.cljs$lang$type;\r\n} else {\r\nreturn and__4109__auto__;\r\n}\r\n})())){\r\nvar type_name = devtools.munging.get_type_name(f);\r\nvar parts = type_name.split(/\\//);\r\nvar basis = (function (){try{return devtools.munging.get_basis(f);\r\n}catch (e56043){var _e__55067__auto__ = e56043;\r\nreturn cljs.core.PersistentVector.EMPTY;\r\n}})();\r\nif((cljs.core.count(parts) <= (2))){\r\n} else {\r\nthrow (new Error(\"Assert failed: (<= (count parts) 2)\"));\r\n}\r\n\r\nwhile(true){\r\nif((cljs.core.count(parts) < (2))){\r\nparts.unshift(null);\r\n\r\ncontinue;\r\n} else {\r\n}\r\nbreak;\r\n}\r\n\r\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(parts),basis);\r\n} else {\r\nreturn null;\r\n}\r\n});\r\ndevtools.munging.protocol_path = (function devtools$munging$protocol_path(protocol_selector){\r\nreturn clojure.string.split.cljs$core$IFn$_invoke$arity$2(protocol_selector,/\\./);\r\n});\r\ndevtools.munging.get_protocol_object = (function devtools$munging$get_protocol_object(protocol_selector){\r\nvar obj = (devtools.munging.get_global_scope.cljs$core$IFn$_invoke$arity$0 ? devtools.munging.get_global_scope.cljs$core$IFn$_invoke$arity$0() : devtools.munging.get_global_scope.call(null));\r\nvar path = devtools.munging.protocol_path(protocol_selector);\r\nwhile(true){\r\nif(cljs.core.empty_QMARK_(path)){\r\nreturn obj;\r\n} else {\r\nif(cljs.core.truth_(goog.isObject(obj))){\r\nvar G__56166 = (obj[cljs.core.first(path)]);\r\nvar G__56167 = cljs.core.rest(path);\r\nobj = G__56166;\r\npath = G__56167;\r\ncontinue;\r\n} else {\r\nreturn null;\r\n}\r\n}\r\nbreak;\r\n}\r\n});\r\ndevtools.munging.protocol_exists_QMARK_ = (function devtools$munging$protocol_exists_QMARK_(protocol_selector){\r\nreturn (!((devtools.munging.get_protocol_object(protocol_selector) == null)));\r\n});\r\ndevtools.munging.get_protocol_selector = (function devtools$munging$get_protocol_selector(key){\r\nvar temp__5733__auto__ = cljs.core.re_matches(/(.*)\\$$/,key);\r\nif(cljs.core.truth_(temp__5733__auto__)){\r\nvar m = temp__5733__auto__;\r\nif((!(clojure.string.includes_QMARK_(key,\"cljs$lang$protocol_mask$partition\")))){\r\nvar protocol_selector = clojure.string.replace(cljs.core.second(m),\"$\",\".\");\r\nif(devtools.munging.protocol_exists_QMARK_(protocol_selector)){\r\nreturn protocol_selector;\r\n} else {\r\nreturn null;\r\n}\r\n} else {\r\nreturn null;\r\n}\r\n} else {\r\nreturn null;\r\n}\r\n});\r\ndevtools.munging.demunge_protocol_selector = (function devtools$munging$demunge_protocol_selector(protocol_selector){\r\nvar parts = cljs.core.map.cljs$core$IFn$_invoke$arity$2(devtools.munging.proper_demunge,devtools.munging.protocol_path(protocol_selector));\r\nvar _ = (((cljs.core.count(parts) >= (2)))?null:(function(){throw (new Error([\"Assert failed: \",[\"expected protocol selector to contain at least one dot: '\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(protocol_selector),\"'\"].join(''),\"\\n\",\"(>= (count parts) 2)\"].join('')))})());\r\nvar ns = clojure.string.join.cljs$core$IFn$_invoke$arity$2(\".\",cljs.core.butlast(parts));\r\nvar name = cljs.core.last(parts);\r\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns,name,protocol_selector], null);\r\n});\r\ndevtools.munging.fast_path_protocols_lookup_table = (new cljs.core.Delay((function (){\r\nreturn new cljs.core.PersistentArrayMap(null, 2, [(0),cljs.core.PersistentHashMap.fromArrays([(8192),(4096),(524288),(128),(1048576),(1),(32768),(4),(268435456),(512),(33554432),(32),(256),(1024),(134217728),(16777216),(64),(262144),(2),(4194304),(131072),(67108864),(8388608),(16),(2097152),(1073741824),(2147483648),(2048),(8),(65536),(16384)],[new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IStack\",\"cljs.core.IStack\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ISet\",\"cljs.core.ISet\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IReduce\",\"cljs.core.IReduce\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"INext\",\"cljs.core.INext\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IKVReduce\",\"cljs.core.IKVReduce\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IFn\",\"cljs.core.IFn\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IDeref\",\"cljs.core.IDeref\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IEmptyableCollection\",\"cljs.core.IEmptyableCollection\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ISorted\",\"cljs.core.ISorted\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IAssociative\",\"cljs.core.IAssociative\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IList\",\"cljs.core.IList\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ASeq\",\"cljs.core.ASeq\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ILookup\",\"cljs.core.ILookup\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IMap\",\"cljs.core.IMap\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IReversible\",\"cljs.core.IReversible\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ISequential\",\"cljs.core.ISequential\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ISeq\",\"cljs.core.ISeq\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IWithMeta\",\"cljs.core.IWithMeta\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ICounted\",\"cljs.core.ICounted\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IHash\",\"cljs.core.IHash\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IMeta\",\"cljs.core.IMeta\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IRecord\",\"cljs.core.IRecord\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ISeqable\",\"cljs.core.ISeqable\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IIndexed\",\"cljs.core.IIndexed\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IEquiv\",\"cljs.core.IEquiv\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IWriter\",\"cljs.core.IWriter\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IPrintWithWriter\",\"cljs.core.IPrintWithWriter\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IMapEntry\",\"cljs.core.IMapEntry\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ICollection\",\"cljs.core.ICollection\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IDerefWithTimeout\",\"cljs.core.IDerefWithTimeout\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IVector\",\"cljs.core.IVector\"], null)]),(1),cljs.core.PersistentHashMap.fromArrays([(8192),(4096),(128),(1),(32768),(4),(512),(32),(256),(1024),(64),(2),(131072),(16),(2048),(8),(65536),(16384)],[new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ICloneable\",\"cljs.core.ICloneable\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"INamed\",\"cljs.core.INamed\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ITransientSet\",\"cljs.core.ITransientSet\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IPending\",\"cljs.core.IPending\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IReset\",\"cljs.core.IReset\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IEditableCollection\",\"cljs.core.IEditableCollection\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IChunkedSeq\",\"cljs.core.IChunkedSeq\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ITransientMap\",\"cljs.core.ITransientMap\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IMultiFn\",\"cljs.core.IMultiFn\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IChunkedNext\",\"cljs.core.IChunkedNext\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ITransientVector\",\"cljs.core.ITransientVector\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IWatchable\",\"cljs.core.IWatchable\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IIterable\",\"cljs.core.IIterable\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ITransientAssociative\",\"cljs.core.ITransientAssociative\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IComparable\",\"cljs.core.IComparable\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ITransientCollection\",\"cljs.core.ITransientCollection\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"ISwap\",\"cljs.core.ISwap\"], null),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"cljs.core\",\"IAtom\",\"cljs.core.IAtom\"], null)])], null);\r\n}),null));\r\ndevtools.munging.key_for_protocol_partition = (function devtools$munging$key_for_protocol_partition(partition){\r\nreturn [\"cljs$lang$protocol_mask$partition\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(partition),\"$\"].join('');\r\n});\r\ndevtools.munging.scan_fast_path_protocols_partition = (function devtools$munging$scan_fast_path_protocols_partition(obj,partition){\r\nif(typeof partition === 'number'){\r\n} else {\r\nthrow (new Error(\"Assert failed: (number? partition)\"));\r\n}\r\n\r\nvar partition_key = devtools.munging.key_for_protocol_partition(partition);\r\nvar partition_bits = (function (){var or__4120__auto__ = (obj[partition_key]);\r\nif(cljs.core.truth_(or__4120__auto__)){\r\nreturn or__4120__auto__;\r\n} else {\r\nreturn (0);\r\n}\r\n})();\r\nif((partition_bits > (0))){\r\nvar lookup_table = cljs.core.get.cljs$core$IFn$_invoke$arity$2(cljs.core.deref(devtools.munging.fast_path_protocols_lookup_table),partition);\r\nvar _ = ((cljs.core.map_QMARK_(lookup_table))?null:(function(){throw (new Error([\"Assert failed: \",[\"fast-path-protocols-lookup-table does not contain lookup table for partition \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(partition)].join(''),\"\\n\",\"(map? lookup-table)\"].join('')))})());\r\nvar _STAR_ = (function (accum,p__56066){\r\nvar vec__56067 = p__56066;\r\nvar bit = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56067,(0),null);\r\nvar protocol = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56067,(1),null);\r\nif(((partition_bits & bit) === (0))){\r\nreturn accum;\r\n} else {\r\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(accum,protocol);\r\n}\r\n});\r\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(_STAR_,cljs.core.PersistentVector.EMPTY,lookup_table);\r\n} else {\r\nreturn null;\r\n}\r\n});\r\ndevtools.munging.scan_fast_path_protocols = (function devtools$munging$scan_fast_path_protocols(obj){\r\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.concat,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(devtools.munging.scan_fast_path_protocols_partition,obj),cljs.core.range.cljs$core$IFn$_invoke$arity$1((2))));\r\n});\r\ndevtools.munging.scan_slow_path_protocols = (function devtools$munging$scan_slow_path_protocols(obj){\r\nvar keys = goog.object.getKeys(obj);\r\nvar selectors = cljs.core.keep.cljs$core$IFn$_invoke$arity$2(devtools.munging.get_protocol_selector,keys);\r\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(devtools.munging.demunge_protocol_selector,selectors);\r\n});\r\ndevtools.munging.make_protocol_descriptor = (function devtools$munging$make_protocol_descriptor(ns,name,selector,fast_QMARK_){\r\nreturn new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"ns\",\"ns\",441598760),ns,new cljs.core.Keyword(null,\"name\",\"name\",1843675177),name,new cljs.core.Keyword(null,\"selector\",\"selector\",762528866),selector,new cljs.core.Keyword(null,\"fast?\",\"fast?\",-1813307150),fast_QMARK_], null);\r\n});\r\ndevtools.munging.convert_to_protocol_descriptor = (function devtools$munging$convert_to_protocol_descriptor(fast_QMARK_,p__56073){\r\nvar vec__56074 = p__56073;\r\nvar ns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56074,(0),null);\r\nvar name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56074,(1),null);\r\nvar selector = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56074,(2),null);\r\nreturn devtools.munging.make_protocol_descriptor(ns,name,selector,fast_QMARK_);\r\n});\r\ndevtools.munging.protocol_descriptors_comparator = (function devtools$munging$protocol_descriptors_comparator(a,b){\r\nreturn cljs.core.compare(new cljs.core.Keyword(null,\"name\",\"name\",1843675177).cljs$core$IFn$_invoke$arity$1(a),new cljs.core.Keyword(null,\"name\",\"name\",1843675177).cljs$core$IFn$_invoke$arity$1(b));\r\n});\r\ndevtools.munging.scan_protocols = (function devtools$munging$scan_protocols(obj){\r\nvar fast_path_protocols = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(devtools.munging.convert_to_protocol_descriptor,true),devtools.munging.scan_fast_path_protocols(obj));\r\nvar slow_path_protocols = cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(devtools.munging.convert_to_protocol_descriptor,false),devtools.munging.scan_slow_path_protocols(obj));\r\nvar all_protocols = cljs.core.concat.cljs$core$IFn$_invoke$arity$2(fast_path_protocols,slow_path_protocols);\r\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2(devtools.munging.protocol_descriptors_comparator,all_protocols);\r\n});\r\ndevtools.munging.collect_protocol_methods = (function devtools$munging$collect_protocol_methods(obj,protocol_selector){\r\nvar key_prefix = clojure.string.replace(protocol_selector,/\\./,\"\\\\$\");\r\nvar pattern = cljs.core.re_pattern([\"^\",key_prefix,\"\\\\$(.*)\\\\$arity\\\\$(\\\\d+)$\"].join(''));\r\nvar all_keys = goog.object.getKeys(obj);\r\nvar matches = cljs.core.keep.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.core.re_matches,pattern),all_keys);\r\nvar methods$ = cljs.core.group_by(cljs.core.second,matches);\r\nvar match_to_arity = (function (match){\r\nvar arity = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(match,(2));\r\nreturn parseInt(arity,(10));\r\n});\r\nvar match_arity_comparator = (function (a,b){\r\nreturn cljs.core.compare(match_to_arity(a),match_to_arity(b));\r\n});\r\nvar post_process = (function (p__56086){\r\nvar vec__56087 = p__56086;\r\nvar munged_name = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56087,(0),null);\r\nvar matches__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__56087,(1),null);\r\nvar name = devtools.munging.proper_demunge(munged_name);\r\nvar sorted_matches = cljs.core.sort.cljs$core$IFn$_invoke$arity$2(match_arity_comparator,matches__$1);\r\nvar sorted_fns = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__56085_SHARP_){\r\nreturn (obj[cljs.core.first(p1__56085_SHARP_)]);\r\n}),sorted_matches);\r\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [name,sorted_fns], null);\r\n});\r\nvar by_name_comparator = (function (a,b){\r\nreturn cljs.core.compare(cljs.core.first(a),cljs.core.first(b));\r\n});\r\nreturn cljs.core.sort.cljs$core$IFn$_invoke$arity$2(by_name_comparator,cljs.core.map.cljs$core$IFn$_invoke$arity$2(post_process,methods$));\r\n});\r\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","This namespace implements various heuristics to map Javascript names back to corresponding ClojureScript names.\n  The functionality here heavily depends on observed ClojureScript compiler and runtime behaviour (fragile!).\n  Answers given by functions in this namespace cannot be perfect because generated Javascript naming schemes produced by\n  ClojureScript compiler were not designed with easy reversibility in mind. We recommend this functionality to be used for\n  presentation in the UI only. The goal here is to provide user with more familiar view of runtime state of her app\n  in most common cases (on best effort basis).\n\n  Our main weapons in this uneven fight are:\n    1. munged function names as they appear in Javascript (generated by ClojureScript)\n    2. we can also analyze function sources accessible via .toString\n    3. special cljs$core$IFn$_invoke protocol props generated for multi-arity functions\n\n  We can also cheat and look at runtime state of browser environment to determine some answers about namespaces.\n\n  This code can be used only in non-advanced builds!\n\n  If you discovered breakage or a new case which should be covered by this code, please open an issue:\n    https://github.com/binaryage/cljs-devtools/issues","~:file","devtools/munging.cljs","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",21],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index"],"~:use-macros",["^ ","~$get-fast-path-protocol-partitions-count","~$devtools.munging","~$get-fast-path-protocols-lookup-table","^E","~$oget","~$devtools.oops","~$ocall","^H","~$safe-call","^H"],"~:excludes",["~#set",["~$js-reserved?"]],"~:macros",["^ ","^D",["^ ","~:arglists",["~#list",[[]]],"^8",28,"^9",1,"^7","devtools/munging.clj","~:name","~$devtools.munging/get-fast-path-protocol-partitions-count","~:ns","^E","~:macro",true],"^F",["^ ","^O",["^P",[[]]],"^8",21,"^9",1,"^7","devtools/munging.clj","^Q","~$devtools.munging/get-fast-path-protocols-lookup-table","^S","^E","^T",true],"~$get-fast-path-protocols",["^ ","^O",["^P",[[]]],"^8",12,"^9",1,"^7","devtools/munging.clj","^Q","~$devtools.munging/get-fast-path-protocols","^S","^E","^T",true]],"^Q","^E","~:op","^S","~:imports",["^ ","~$StringBuffer","~$goog.string.StringBuffer"],"~:requires",["^ ","~$cljs.core","^11","~$gobj","~$goog.object","~$goog","^14","^13","^13","^[","^[","^Z","^[","~$string","~$clojure.string","~$devtools.context","^17","^16","^16","~$context","^17"],"~:seen",["^L",["~:require","~:require-macros"]],"~:uses",null,"^1;",["^ ","^E","^E","^H","^H","^11","^11"],"~:form",["^P",["~$ns","^E","This namespace implements various heuristics to map Javascript names back to corresponding ClojureScript names.\n  The functionality here heavily depends on observed ClojureScript compiler and runtime behaviour (fragile!).\n  Answers given by functions in this namespace cannot be perfect because generated Javascript naming schemes produced by\n  ClojureScript compiler were not designed with easy reversibility in mind. We recommend this functionality to be used for\n  presentation in the UI only. The goal here is to provide user with more familiar view of runtime state of her app\n  in most common cases (on best effort basis).\n\n  Our main weapons in this uneven fight are:\n    1. munged function names as they appear in Javascript (generated by ClojureScript)\n    2. we can also analyze function sources accessible via .toString\n    3. special cljs$core$IFn$_invoke protocol props generated for multi-arity functions\n\n  We can also cheat and look at runtime state of browser environment to determine some answers about namespaces.\n\n  This code can be used only in non-advanced builds!\n\n  If you discovered breakage or a new case which should be covered by this code, please open an issue:\n    https://github.com/binaryage/cljs-devtools/issues",["^P",["~:refer-clojure","~:exclude",["^M"]]],["^P",["^1;",["^E","~:refer",["^D","^F"]],["^H","^1A",["^G","^I","^J"]]]],["^P",["^1:",["^16","~:as","^15"],["^17","^1B","^18"],["^13","^1B","^12"]]],["^P",["~:import",["~$goog.string","^Z"]]]]],"~:flags",["^ ","^1;",["^L",[]],"^1:",["^L",[]]],"~:js-deps",["^ "],"~:deps",["^14","^11","^16","^17","^13","^["]],"^S","^E","~:resource-id",["~:shadow.build.classpath/resource","devtools/munging.cljs"],"~:compiled-at",1589213810714,"~:resource-name","devtools/munging.cljs","~:warnings",[],"~:source","(ns devtools.munging\n  \"This namespace implements various heuristics to map Javascript names back to corresponding ClojureScript names.\n  The functionality here heavily depends on observed ClojureScript compiler and runtime behaviour (fragile!).\n  Answers given by functions in this namespace cannot be perfect because generated Javascript naming schemes produced by\n  ClojureScript compiler were not designed with easy reversibility in mind. We recommend this functionality to be used for\n  presentation in the UI only. The goal here is to provide user with more familiar view of runtime state of her app\n  in most common cases (on best effort basis).\n\n  Our main weapons in this uneven fight are:\n    1. munged function names as they appear in Javascript (generated by ClojureScript)\n    2. we can also analyze function sources accessible via .toString\n    3. special cljs$core$IFn$_invoke protocol props generated for multi-arity functions\n\n  We can also cheat and look at runtime state of browser environment to determine some answers about namespaces.\n\n  This code can be used only in non-advanced builds!\n\n  If you discovered breakage or a new case which should be covered by this code, please open an issue:\n    https://github.com/binaryage/cljs-devtools/issues\"\n  (:refer-clojure :exclude [js-reserved?])\n  (:require-macros [devtools.munging :refer [get-fast-path-protocol-partitions-count\n                                             get-fast-path-protocols-lookup-table]]\n                   [devtools.oops :refer [oget ocall safe-call]])\n  (:require [clojure.string :as string]\n            [devtools.context :as context]\n            [goog.object :as gobj])\n  (:import [goog.string StringBuffer]))\n\n(declare collect-fn-arities)\n\n(def dollar-replacement \"~﹩~\")\n(def max-fixed-arity-to-scan 64)\n\n; -- helpers ----------------------------------------------------------------------------------------------------------------\n\n(defn ^:dynamic get-global-scope []\n  (context/get-root))\n\n(defn js-reserved? [x]\n  ; js-reserved? is private as of ClojureScript 1.9.293\n  (if-let [js-reserved-fn (oget (get-global-scope) \"cljs\" \"core\" \"js_reserved_QMARK_\")]\n    (js-reserved-fn x)))\n\n(defn get-fn-source-safely [f]\n  (try\n    (if (js-in \"toString\" f)\n      (ocall f \"toString\")\n      \"\")\n    (catch :default _\n      \"\")))\n\n(defn get-fn-fixed-arity [f n]\n  (oget f (str \"cljs$core$IFn$_invoke$arity$\" n)))\n\n(defn get-fn-variadic-arity [f]\n  (oget f (str \"cljs$core$IFn$_invoke$arity$variadic\")))\n\n(defn get-fn-max-fixed-arity [f]\n  (oget f \"cljs$lang$maxFixedArity\"))\n\n(defn get-type-name [t]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (try\n      ; we cannot use (type->str f) because it does not work for defrecords as of v1.9.89\n      ; instead we rely on .cljs$lang$ctorPrWriter which is defined for both deftypes and defrecords\n      ; and it is used here: https://github.com/clojure/clojurescript/blob/cfbefad0b9f2ae9af92ebc2ec211c8472a884ddf/src/main/cljs/cljs/core.cljs#L9173\n      ; relevant JIRA ticket: http://dev.clojure.org/jira/browse/CLJS-1725\n      (ocall t \"cljs$lang$ctorPrWriter\" t writer)\n      (catch :default _\n        \"?\"))\n    (-flush writer)\n    (str sb)))\n\n(defn char-to-subscript\n  \"Given a character with a single digit converts it into a subscript character.\n  Zero chracter maps to unicode 'SUBSCRIPT ZERO' (U+2080).\"\n  [char]\n  {:pre [(string? char)\n         (= (count char) 1)]}\n  (let [char-code (ocall (js/String. char) \"charCodeAt\" 0)                                                                    ; this is an ugly trick to overcome a V8? bug, char string might not be a real string \"object\"\n        num-code (- char-code 48)\n        subscript-code (+ 0x2080 num-code)]\n    (ocall js/String \"fromCharCode\" subscript-code)))\n\n(defn make-subscript\n  \"Given a subscript number converts it into a string representation consisting of unicode subscript characters (digits).\"\n  [subscript]\n  {:pre [(number? subscript)]}\n  (string/join (map char-to-subscript (str subscript))))\n\n(defn char-to-superscript\n  \"Given a character with a single digit converts it into a superscript character.\n  Zero chracter maps to unicode 'SUPERSCRIPT ZERO' (U+2070).\"\n  [char]\n  {:pre [(string? char)\n         (= (count char) 1)]}\n  (let [char-code (ocall (js/String. char) \"charCodeAt\" 0)                                                                    ; this is an ugly trick to overcome a V8? bug, char string might not be a real string \"object\"\n        num-code (- char-code 48)\n        superscript-code (case num-code                                                                                       ; see https://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts\n                           1 0x00B9\n                           2 0x00B2\n                           3 0x00B3\n                           (+ 0x2070 num-code))]\n    (ocall js/String \"fromCharCode\" superscript-code)))\n\n(defn make-superscript\n  \"Given a superscript number converts it into a string representation consisting of unicode superscript characters (digits).\"\n  [superscript]\n  {:pre [(number? superscript)]}\n  (string/join (map char-to-superscript (str superscript))))\n\n; -- cljs naming conventions ------------------------------------------------------------------------------------------------\n\n(defn cljs-fn-name?\n  \"Given a Javascript name answers if the name was likely generated by ClojureScript.\n  We use a simple heuristic here:\n    The name must contain at least two separate dollars because we assume two-segment namespaces.\"\n  [munged-name]\n  (if (string? munged-name)\n    (some? (re-matches #\"^[^$]*\\$[^$]+\\$.*$\" munged-name))))\n\n(defn parse-fn-source\n  \"Given a function source code parses out [name args]. Note that both strings are still munged.\n  Suitable for further processing.\n\n  For exampe for input below the function will return [\\\"devtools_sample$core$hello\\\" \\\"name, unused_param\\\"]:\n\n  function devtools_sample$core$hello(name, unused_param){\n    return [cljs.core.str(\\\"hello, \\\"),cljs.core.str(name),cljs.core.str(\\\"!\\\")].join('');\n  }\n  \"\n  [fn-source]\n  (if-let [meat (second (re-find #\"function\\s(.*?)\\{\" fn-source))]\n    (if-let [match (re-find #\"(.*?)\\((.*)\\)\" meat)]\n      (rest match))))\n\n(defn trivial-fn-source? [fn-source]\n  {:pre [(string? fn-source)]}\n  (or (some? (re-matches #\"function\\s*\\(\\s*\\)\\s*\\{\\s*\\}\\s*\" fn-source))\n      (some? (re-matches #\"function.*\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}\\s*\" fn-source))\n      (some? (re-matches #\"function anonymous\\(\\s*\\)\\s*\\{\\s*\\}\" fn-source))))\n\n(defn cljs-fn?\n  \"Given a Javascript function object returns true if the function looks like a ClojureScript function.\n\n  Uses various heuristics:\n    1. must be fn? (is javascript function or satisfies Fn and IFn protocols)\n    2. and name must be cljs-fn-name? (name can come from f.name or parsed out of function source)\n    3. or if anonymous function, must be non-trivial\"\n  [f]\n  (if (safe-call fn? false f)                                                                                                 ; calling fn? on window object could throw for some weird reason\n    (let [name (oget f name)]\n      (if-not (empty? name)\n        (cljs-fn-name? name)\n        (let [fn-source (get-fn-source-safely f)]\n          (let [[name] (parse-fn-source fn-source)]\n            (if-not (empty? name)\n              (cljs-fn-name? name)\n              (not (trivial-fn-source? fn-source)))))))))                                                                     ; we assume non-trivial anonymous functions to come from cljs\n\n; -- demunging --------------------------------------------------------------------------------------------------------------\n\n(defn dollar-preserving-demunge\n  \"Standard cljs.core/demunge is too agresive in replacing dollars.\n  This wrapper function works around it by leaving dollars intact.\"\n  [munged-name]\n  (-> munged-name\n      (string/replace \"$\" dollar-replacement)\n      (demunge)\n      (string/replace dollar-replacement \"$\")))\n\n(defn revert-reserved [s]\n  (or (if-let [m (re-matches #\"(.*)\\$\" s)]\n        (if (js-reserved? (second m))\n          (second m)))\n      s))\n\n(defn reserved-aware-demunge [munged-name]\n  (-> munged-name\n      (dollar-preserving-demunge)\n      (revert-reserved)))\n\n(defn proper-demunge [munged-name]\n  (reserved-aware-demunge munged-name))\n\n(defn proper-arg-demunge [munged-arg-name]\n  (-> munged-arg-name\n      (proper-demunge)\n      (string/replace #\"^-(.*)$\" \"_$1\")))                                                                                     ; leading dash was probably a leading underscore (convention)\n\n(defn proper-ns-demunge [munged-ns-name]\n  (-> munged-ns-name\n      (proper-demunge)\n      (string/replace \"$\" \".\")))\n\n(defn ns-exists? [ns-module-name]\n  {:pre [(string? ns-module-name)]}\n  (if-let [goog-namespaces (oget (get-global-scope) \"goog\" \"dependencies_\" \"nameToPath\")]\n    (some? (oget goog-namespaces ns-module-name))))\n\n(defn detect-namespace-prefix\n  \"Given a name broken into namespace parts returns [detected-ns remaining-parts],\n  where detected-ns is a string representing longest detected existing namespace and\n  remaining-parts is a vector of remaing input parts not included in the detected-ns concatenation.\n\n  For given input [\\\"cljs\\\" \\\"core\\\" \\\"first\\\"] returns [\\\"cljs.core\\\" [\\\"first\\\"]] (asumming cljs.core exists)\"\n  [tokens & [ns-detector]]\n  (let [effective-detector (or ns-detector ns-exists?)]\n    (loop [name-tokens []\n           remaining-tokens tokens]\n      (if (empty? remaining-tokens)\n        [\"\" name-tokens]\n        (let [ns-name (string/join \".\" remaining-tokens)]\n          (if (effective-detector ns-name)\n            [ns-name name-tokens]\n            (recur (concat [(last remaining-tokens)] name-tokens) (butlast remaining-tokens))))))))\n\n(defn normalize-arity [arity-tokens]\n  (if-not (empty? arity-tokens)\n    (let [arity (first arity-tokens)]\n      (case arity\n        \"variadic\" arity\n        (js/parseInt arity 10)))))\n\n(defn strip-arity [tokens]\n  (let [[prefix-tokens arity-tokens] (split-with #(not= % \"arity\") tokens)]\n    [prefix-tokens (normalize-arity (rest arity-tokens))]))\n\n(defn parse-protocol [tokens detector]\n  (loop [remaining-tokens tokens\n         name-tokens []]\n    (if (empty? remaining-tokens)\n      [name-tokens]\n      (let [[protocol-ns name-and-method-tokens] (detect-namespace-prefix remaining-tokens detector)]\n        (if (empty? protocol-ns)\n          (recur (rest remaining-tokens) (conj name-tokens (first remaining-tokens)))\n          [name-tokens protocol-ns (first name-and-method-tokens) (rest name-and-method-tokens)])))))                         ; we assume protocol names are always a single-token\n\n(defn break-munged-name\n  \"Given a munged-name from Javascript lands attempts to break it into:\n  [fn-ns fn-name protocol-ns protocol-name protocol-method arity].\n\n  Protocol and arity elements are optional. Function elements are always present or \\\"\\\".\n\n  examples for input:\n    cljs$core$rest => ['cljs.core', 'rest']\n    cljs.core.reduce$cljs$core$IFn$_invoke$arity$3 => ['cljs.core' 'reduce' 'cljs.core' 'IFn' '_invoke' 3]\"\n  ([munged-name]\n   (break-munged-name munged-name nil))\n  ([munged-name ns-detector]\n   (if (empty? munged-name)\n     [\"\" \"\"]\n     (let [effective-detector (or ns-detector ns-exists?)\n           tokens (vec (.split munged-name #\"[$.]\"))\n           [tokens arity] (strip-arity tokens)\n           [fn-ns tokens] (detect-namespace-prefix tokens effective-detector)\n           ; remianing parts contains function name,\n           ; but may be optionally followed by protocol namespace, protocol name and protocol method\n           [fn-name-tokens protocol-ns protocol-name protocol-method-tokens] (parse-protocol tokens effective-detector)\n           fn-name (string/join \"$\" fn-name-tokens)\n           protocol-method (if protocol-method-tokens (string/join \"$\" protocol-method-tokens))]\n       [fn-ns fn-name protocol-ns protocol-name protocol-method arity]))))\n\n(defn break-and-demunge-name\n  \"Given a munged-name from Javascript lands attempts to break it into a namespace part and remaining short name.\n  Then applies appropriate demunging on them and returns ClojureScript versions of the names.\"\n  ([munged-name]\n   (break-and-demunge-name munged-name nil))\n  ([munged-name ns-detector]\n   (let [result (break-munged-name munged-name ns-detector)\n         [munged-ns munged-name munged-protocol-ns munged-protocol-name munged-protocol-method arity] result]\n     [(proper-ns-demunge munged-ns)\n      (proper-demunge munged-name)\n      (if munged-protocol-ns (proper-ns-demunge munged-protocol-ns))\n      (if munged-protocol-name (proper-demunge munged-protocol-name))\n      (if munged-protocol-method (proper-demunge munged-protocol-method))\n      arity])))\n\n; -- fn info ----------------------------------------------------------------------------------------------------------------\n\n(defn parse-fn-source-info\n  \"Given function source code tries to retrieve [ns name & args] on best effort basis, where\n  ns is demunged namespace part of the function name (or \\\"\\\" if namespace cannot be detected)\n  name is demunged short name (or \\\"\\\" if function is anonymous or name cannot be retrieved)\n  args is optional number of demunged argument names.\n\n  Please note that this function always returns a vector with something. In worst cases [\\\"\\\" \\\"\\\"].\n  \"\n  [fn-source]\n  (if-let [[munged-name args] (parse-fn-source fn-source)]\n    (let [[ns name] (break-and-demunge-name munged-name)\n          demunged-args (map (comp proper-arg-demunge string/trim) (string/split args #\",\"))]\n      (concat [ns name] demunged-args))\n    [\"\" \"\"]))\n\n(defn parse-fn-info\n  \"Given Javascript function object tries to retrieve [ns name & args] as in parse-fn-source-info (on best effort basis).\"\n  [f]\n  (let [fn-source (get-fn-source-safely f)]\n    (parse-fn-source-info fn-source)))\n\n(defn parse-fn-info-deep\n  \"Given a Javascript function object tries to retrieve [ns name & args] as in parse-fn-info (on best effort basis).\n\n  The difference from parse-fn-info is that this function prefers to read args from arities if available.\n  It recurses arbitrary deep following IFn protocol leads.\n\n  If we hit multi-arity situation in leaf, we don't attempt to list arguments and return ::multi-arity placeholder instead.\n\n  The reason for reading arities is that it gives more accurate parameter names in some cases.\n  We observed that variadic functions don't always contain original parameter names, but individual IFn arity functions do.\"\n  [f]\n  (let [fn-info (parse-fn-info f)\n        arities (collect-fn-arities f)]\n    (if (some? arities)\n      (if (> (count arities) 1)\n        (concat (take 2 fn-info) ::multi-arity)\n        (concat (take 2 fn-info) (drop 2 (parse-fn-info-deep (second (first arities))))))\n      fn-info)))\n\n; -- support for human-readable names ---------------------------------------------------------------------------------------\n\n(defn find-index-of-human-prefix\n  \"Given a demunged ClojureScript parameter name. Tries to detect human readable part and returns the index where it ends.\n  Returns nil if no prefix can be detected.\n\n  The idea is to convert macro-generated parameters and other generated names to more friendly names.\n  We observed that param names generated by gensym have prefix followed by big numbers.\n  Other generated names contain two dashes after prefix (originally probably using underscores).\"\n  [name]\n  (let [sep-start (.indexOf name \"--\")\n        num-prefix (count (second (re-find #\"(.*?)\\d{2,}\" name)))\n        finds (filter pos? [sep-start num-prefix])]\n    (if-not (empty? finds)\n      (apply min finds))))\n\n(defn humanize-name\n  \"Given a name and intermediate state. Convert name to a human readable version by keeping human readable prefix with\n  optional subscribt postfix and store it in ::result. Subscript number is picked based on state. State keeps track of\n  previously assigned subscripts. Returns a new state.\"\n  [state name]\n  (let [index (find-index-of-human-prefix name)\n        prefix (if (> index 0) (.substring name 0 index) name)]\n    (if-let [subscript (get state prefix)]\n      (-> state\n          (update ::result conj (str prefix (make-subscript subscript)))\n          (update prefix inc))\n      (-> state\n          (update ::result conj prefix)\n          (assoc prefix 2)))))\n\n(defn humanize-names\n  \"Given a list of names, returns a list of human-readable versions of those names.\n  It detects human-readable prefix using a simple heuristics. When names repeat it assigns simple subscripts starting with 2.\n  Subscripts are assigned left-to-right.\n\n  Given [\\\"p--a\\\" \\\"p--b\\\" \\\"x\\\" \\\"p--c\\\"] returns [\\\"p\\\" \\\"p₂\\\" \\\"x\\\" \\\"p₃\\\"]\"\n  [names]\n  (with-meta (::result (reduce humanize-name {::result []} names)) (meta names)))\n\n; -- arities ----------------------------------------------------------------------------------------------------------------\n\n(defn collect-fn-fixed-arities [f max-arity]\n  (loop [arity 0\n         collection {}]\n    (if (> arity max-arity)\n      collection\n      (recur (inc arity) (if-let [arity-fn (get-fn-fixed-arity f arity)]\n                           (assoc collection arity arity-fn)\n                           collection)))))\n\n(defn collect-fn-variadic-arities [f]\n  (if-let [variadic-arity (get-fn-variadic-arity f)]\n    {::variadic variadic-arity}))\n\n(defn review-arity [[arity arity-fn]]\n  (let [sub-arities (collect-fn-arities arity-fn)]\n    (if (::variadic sub-arities)\n      [::variadic arity-fn]\n      [arity arity-fn])))\n\n(defn review-arities\n  \"Some arities can be marked as fixed arity but in fact point to a variadic-arity function. We want to detect this case\n  and turn such improperly categorized arities to ::variadic.\"\n  [arities]\n  (if (::variadic arities)\n    arities\n    (into {} (map review-arity arities))))\n\n(defn collect-fn-arities\n  \"Given a Javascript function object, tries to inspect known arity properties generated by ClojureScript compiler and\n  collects all available arity functions into a map. Arities are keyed by arity count and variadic arity gets ::variadic key.\"\n  [f]\n  (let [max-fixed-arity (get-fn-max-fixed-arity f)\n        fixed-arities (collect-fn-fixed-arities f (or max-fixed-arity max-fixed-arity-to-scan))                               ; we cannot rely on cljs$lang$maxFixedArity when people implement IFn protocol by hand\n        variadic-arities (collect-fn-variadic-arities f)\n        arities (review-arities (merge fixed-arities variadic-arities))]\n    (if-not (empty? arities)\n      arities)))\n\n; -- args lists -------------------------------------------------------------------------------------------------------------\n\n(defn arity-keywords-comparator\n  \"::variadic goes last, other keywords compare by name.\"\n  [x y]\n  (cond\n    (= ::variadic x) 1\n    (= ::variadic y) -1\n    :else (compare (name x) (name y))))\n\n(defn arities-key-comparator\n  \"numbers go first (ordered), then keywords (ordered by name), and then ::variadic sticks last\"\n  [x y]\n  (let [kx? (keyword? x)\n        ky? (keyword? y)]\n    (cond\n      (and kx? ky?) (arity-keywords-comparator x y)\n      kx? 1\n      ky? -1\n      :else (compare x y))))\n\n(defn arities-to-args-lists*\n  [arities]\n  (let [sorted-keys (sort arities-key-comparator (keys arities))\n        sorted-fns (map #(get arities %) sorted-keys)\n        sorted-infos (map parse-fn-info-deep sorted-fns)\n        sorted-args-lists (map #(drop 2 %) sorted-infos)]\n    (if (= (last sorted-keys) ::variadic)\n      (concat (butlast sorted-args-lists) [(vary-meta (last sorted-args-lists) assoc ::variadic true)])\n      sorted-args-lists)))\n\n(defn arities-to-args-lists\n  \"Given a map of arity functions. Tries to parse individual functions and prepare an arguments list for each arity.\n  Returned list of arguments list is sorted by arity count, variadic arity goes last if available.\n\n  The function also optionally humanizes argument names in each arguments list if requested.\"\n  [arities & [humanize?]]\n  (let [args-lists (arities-to-args-lists* arities)]\n    (if humanize?\n      (map humanize-names args-lists)\n      args-lists)))\n\n; -- UI presentation --------------------------------------------------------------------------------------------------------\n\n(defn args-lists-to-strings\n  \"Converts a list of arguments lists into a list of strings suitable for UI presentation.\"\n  [args-lists spacer-symbol multi-arity-symbol rest-symbol]\n  (let [string-mapper (fn [arg]\n                        (case arg\n                          ::multi-arity multi-arity-symbol\n                          arg))\n        printer (fn [args-list]\n                  (let [variadic? (::variadic (meta args-list))\n                        args-strings (map string-mapper args-list)]\n                    (str (string/join spacer-symbol (butlast args-strings))\n                         (if variadic? rest-symbol spacer-symbol)\n                         (last args-strings))))]\n    (->> args-lists\n         (map printer)\n         (map string/trim))))\n\n(defn extract-arities [f humanize? spacer-symbol multi-arity-symbol rest-symbol]\n  (-> (or (collect-fn-arities f) {:naked f})\n      (arities-to-args-lists humanize?)\n      (args-lists-to-strings spacer-symbol multi-arity-symbol rest-symbol)))\n\n(defn common-protocol? [protocol-ns protocol-name]\n  (and (= protocol-ns \"cljs.core\")\n       (= protocol-name \"IFn\")))\n\n(defn present-fn-part [fn-ns fn-name include-ns?]\n  (str\n    (if (and include-ns? (not (empty? fn-ns))) (str fn-ns \"/\"))\n    fn-name))\n\n(defn present-protocol-part [protocol-ns protocol-name protocol-method include-protocol-ns?]\n  (str (if include-protocol-ns? protocol-ns)\n       (if-not (empty? protocol-name) (str (if include-protocol-ns? \".\") protocol-name))\n       (if-not (empty? protocol-method) (str (if (or include-protocol-ns? (not (empty? protocol-name))) \":\")\n                                             protocol-method))))\n\n(defn present-function-name\n  \"Given javascript function name tries to present it as plain string for display in UI on best effort basis.\"\n  [munged-name options]\n  (let [{:keys [include-ns? include-protocol-ns? silence-common-protocols? ns-detector]} options\n        [fn-ns fn-name protocol-ns protocol-name protocol-method arity] (break-and-demunge-name munged-name ns-detector)\n        arity-str (if (some? arity)\n                    (if (= arity \"variadic\")\n                      \"\\u207F\"                                                                                                ; 'SUPERSCRIPT LATIN SMALL LETTER N' (U+207F)\n                      (make-superscript arity)))]\n    (if (empty? fn-name)\n      munged-name\n      (let [fn-part (present-fn-part fn-ns fn-name include-ns?)\n            protocol-part (if (and protocol-ns\n                                   (not (and silence-common-protocols?\n                                             (common-protocol? protocol-ns protocol-name))))\n                            (present-protocol-part protocol-ns protocol-name protocol-method include-protocol-ns?))]\n        (str\n          (or protocol-part fn-part)\n          arity-str\n          (if protocol-part (str \" (\" fn-part \")\")))))))\n\n; -- types ------------------------------------------------------------------------------------------------------------------\n\n(defn get-basis [f]\n  (ocall f \"getBasis\"))\n\n(defn parse-constructor-info\n  \"Given a Javascript constructor function tries to retrieve [ns name basis]. Returns nil if not a cljs type.\"\n  [f]\n  (if (and (goog/isObject f) (.-cljs$lang$type f))\n    (let [type-name (get-type-name f)\n          parts (.split type-name #\"/\")\n          basis (safe-call get-basis [] f)]\n      (assert (<= (count parts) 2))\n      (while (< (count parts) 2)\n        (.unshift parts nil))\n      (conj (vec parts) basis))))\n\n; -- protocols --------------------------------------------------------------------------------------------------------------\n\n(defn protocol-path [protocol-selector]\n  (string/split protocol-selector #\"\\.\"))\n\n(defn get-protocol-object [protocol-selector]\n  (loop [obj (get-global-scope)\n         path (protocol-path protocol-selector)]\n    (if (empty? path)\n      obj\n      (if (goog/isObject obj)\n        (recur (oget obj (first path)) (rest path))))))\n\n(defn protocol-exists? [protocol-selector]\n  (some? (get-protocol-object protocol-selector)))\n\n(defn get-protocol-selector [key]\n  (if-let [m (re-matches #\"(.*)\\$$\" key)]\n    (if-not (string/includes? key \"cljs$lang$protocol_mask$partition\")\n      (let [protocol-selector (string/replace (second m) \"$\" \".\")]\n        (if (protocol-exists? protocol-selector)\n          protocol-selector)))))\n\n(defn demunge-protocol-selector [protocol-selector]\n  (let [parts (map proper-demunge (protocol-path protocol-selector))\n        _ (assert (>= (count parts) 2)\n                  (str \"expected protocol selector to contain at least one dot: '\" protocol-selector \"'\"))\n        ns (string/join \".\" (butlast parts))\n        name (last parts)]\n    [ns name protocol-selector]))\n\n(def fast-path-protocols-lookup-table (delay (get-fast-path-protocols-lookup-table)))\n\n(defn key-for-protocol-partition [partition]\n  (str \"cljs$lang$protocol_mask$partition\" partition \"$\"))\n\n(defn scan-fast-path-protocols-partition [obj partition]\n  {:pre [(number? partition)]}\n  (let [partition-key (key-for-protocol-partition partition)\n        partition-bits (or (oget obj partition-key) 0)]\n    (if (> partition-bits 0)\n      (let [lookup-table (get @fast-path-protocols-lookup-table partition)\n            _ (assert (map? lookup-table)\n                      (str \"fast-path-protocols-lookup-table does not contain lookup table for partition \" partition))\n            * (fn [accum [bit protocol]]\n                (if (zero? (bit-and partition-bits bit))\n                  accum\n                  (conj accum protocol)))]\n        (reduce * [] lookup-table)))))\n\n(defn scan-fast-path-protocols [obj]\n  (apply concat (map (partial scan-fast-path-protocols-partition obj) (range (get-fast-path-protocol-partitions-count)))))\n\n(defn scan-slow-path-protocols [obj]\n  (let [keys (gobj/getKeys obj)\n        selectors (keep get-protocol-selector keys)]\n    (map demunge-protocol-selector selectors)))\n\n(defn make-protocol-descriptor [ns name selector fast?]\n  {:ns       ns\n   :name     name\n   :selector selector\n   :fast?    fast?})\n\n(defn convert-to-protocol-descriptor [fast? [ns name selector]]\n  (make-protocol-descriptor ns name selector fast?))\n\n(defn protocol-descriptors-comparator [a b]\n  (compare (:name a) (:name b)))\n\n(defn scan-protocols [obj]\n  (let [fast-path-protocols (map (partial convert-to-protocol-descriptor true) (scan-fast-path-protocols obj))\n        slow-path-protocols (map (partial convert-to-protocol-descriptor false) (scan-slow-path-protocols obj))\n        all-protocols (concat fast-path-protocols slow-path-protocols)]\n    (sort protocol-descriptors-comparator all-protocols)))\n\n(defn collect-protocol-methods [obj protocol-selector]\n  (let [key-prefix (string/replace protocol-selector #\"\\.\" \"\\\\$\")\n        pattern (re-pattern (str \"^\" key-prefix \"\\\\$(.*)\\\\$arity\\\\$(\\\\d+)$\"))\n        all-keys (gobj/getKeys obj)\n        matches (keep (partial re-matches pattern) all-keys)\n        methods (group-by second matches)\n        match-to-arity (fn [match]\n                         (let [arity (nth match 2)]\n                           (js/parseInt arity 10)))\n        match-arity-comparator (fn [a b]\n                                 (compare (match-to-arity a) (match-to-arity b)))\n        post-process (fn [[munged-name matches]]\n                       (let [name (proper-demunge munged-name)\n                             sorted-matches (sort match-arity-comparator matches)\n                             sorted-fns (map #(oget obj (first %)) sorted-matches)]\n                         [name sorted-fns]))\n        by-name-comparator (fn [a b]\n                             (compare (first a) (first b)))]\n    ; TODO: he we could be able to retrieve parameter lists from protocol definition methods\n    ;       parameter names there are usually more consistent than parameters picked by protocol implementors\n    (sort by-name-comparator (map post-process methods))))\n","~:reader-features",["^L",["~:cljs"]],"~:cljc",false,"~:source-map-compact",["^ ","mappings","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","names",["devtools.munging/dollar-replacement","devtools.munging/max-fixed-arity-to-scan","devtools.munging/get-global-scope","devtools.context/get-root","devtools.munging/js-reserved?","x","temp__5733__auto__","js-reserved-fn","o55594","o55595","devtools.munging/get-fn-source-safely","f","e55601","o__55053__auto__","_","devtools.munging/get-fn-fixed-arity","n","devtools.munging/get-fn-variadic-arity","devtools.munging/get-fn-max-fixed-arity","devtools.munging/get-type-name","t","sb","js/goog.string.StringBuffer","writer","cljs.core/StringBufferWriter","e55706","js/Error","devtools.munging/char-to-subscript","char","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core/count","char-code","js/String","num-code","subscript-code","devtools.munging/make-subscript","subscript","clojure.string.join.cljs$core$IFn$_invoke$arity$1","cljs.core.map.cljs$core$IFn$_invoke$arity$2","devtools.munging/char-to-superscript","superscript-code","G__55728","devtools.munging/make-superscript","superscript","devtools.munging/cljs-fn-name?","munged-name","cljs.core/re-matches","devtools.munging/parse-fn-source","fn-source","meat","cljs.core/second","cljs.core/re-find","match","cljs.core/rest","devtools.munging/trivial-fn-source?","devtools.munging/cljs-fn?","_e__55067__auto__","e55785","cljs.core/fn?","name","cljs.core/name","cljs.core/empty?","vec__55787","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","devtools.munging/dollar-preserving-demunge","clojure.string/replace","cljs.core/demunge","devtools.munging/revert-reserved","s","or__4120__auto__","m","devtools.munging/reserved-aware-demunge","devtools.munging/proper-demunge","devtools.munging/proper-arg-demunge","munged-arg-name","devtools.munging/proper-ns-demunge","munged-ns-name","devtools.munging/ns-exists?","ns-module-name","goog-namespaces","o55807","o55808","var_args","args__4736__auto__","len__4730__auto__","i__4731__auto__","argseq__4737__auto__","cljs.core/IndexedSeq","devtools.munging/detect-namespace-prefix","p__55825","vec__55827","seq55819","G__55820","cljs.core/first","cljs.core/next","self__4717__auto__","tokens","ns-detector","effective-detector","name-tokens","remaining-tokens","ns-name","clojure.string.join.cljs$core$IFn$_invoke$arity$2","cljs.core.concat.cljs$core$IFn$_invoke$arity$2","cljs.core/last","cljs.core/butlast","devtools.munging/normalize-arity","arity-tokens","arity","G__55841","js/parseInt","devtools.munging/strip-arity","vec__55844","prefix-tokens","p1__55842#","cljs.core/split-with","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","devtools.munging/parse-protocol","detector","vec__55913","protocol-ns","name-and-method-tokens","devtools.munging.detect_namespace_prefix.cljs$core$IFn$_invoke$arity$variadic","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","G__55923","devtools.munging/break-munged-name","devtools.munging.break_munged_name.cljs$core$IFn$_invoke$arity$2","vec__55931","vec__55934","vec__55937","cljs.core/vec","fn-ns","fn-name-tokens","protocol-name","protocol-method-tokens","fn-name","protocol-method","G__55942","devtools.munging/break-and-demunge-name","devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$2","vec__55944","result","munged-ns","munged-protocol-ns","munged-protocol-name","munged-protocol-method","devtools.munging/parse-fn-source-info","vec__55954","args","vec__55957","ns","devtools.munging.break_and_demunge_name.cljs$core$IFn$_invoke$arity$1","demunged-args","cljs.core.comp.cljs$core$IFn$_invoke$arity$2","clojure.string/trim","clojure.string.split.cljs$core$IFn$_invoke$arity$2","devtools.munging/parse-fn-info","devtools.munging/parse-fn-info-deep","fn-info","arities","devtools.munging/collect-fn-arities","cljs.core.take.cljs$core$IFn$_invoke$arity$2","cljs.core.drop.cljs$core$IFn$_invoke$arity$2","G__55972","devtools.munging/find-index-of-human-prefix","sep-start","num-prefix","finds","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/pos?","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/min","devtools.munging/humanize-name","state","index","prefix","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core.update.cljs$core$IFn$_invoke$arity$4","cljs.core/conj","cljs.core.update.cljs$core$IFn$_invoke$arity$3","cljs.core/inc","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","devtools.munging/humanize-names","names","cljs.core/with-meta","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","cljs.core/meta","devtools.munging/collect-fn-fixed-arities","max-arity","collection","arity-fn","devtools.munging/collect-fn-variadic-arities","variadic-arity","p__55984","vec__55985","devtools.munging/review-arity","sub-arities","devtools.munging/review-arities","cljs.core.into.cljs$core$IFn$_invoke$arity$2","max-fixed-arity","fixed-arities","variadic-arities","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","devtools.munging/arity-keywords-comparator","y","cljs.core/compare","devtools.munging/arities-key-comparator","kx?","cljs.core/Keyword","ky?","devtools.munging/arities-to-args-lists*","sorted-keys","cljs.core.sort.cljs$core$IFn$_invoke$arity$2","cljs.core/keys","sorted-fns","p1__55995#","sorted-infos","sorted-args-lists","p1__55996#","cljs.core.vary_meta.cljs$core$IFn$_invoke$arity$4","cljs.core/assoc","devtools.munging/arities-to-args-lists","p__56006","vec__56007","seq55998","G__55999","humanize?","args-lists","devtools.munging/args-lists-to-strings","spacer-symbol","multi-arity-symbol","rest-symbol","string-mapper","arg","G__56017","printer","args-list","variadic?","args-strings","devtools.munging/extract-arities","devtools.munging.arities_to_args_lists.cljs$core$IFn$_invoke$arity$variadic","devtools.munging/common-protocol?","devtools.munging/present-fn-part","include-ns?","and__4109__auto__","devtools.munging/present-protocol-part","include-protocol-ns?","devtools.munging/present-function-name","options","map__56033","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","vec__56034","silence-common-protocols?","arity-str","fn-part","protocol-part","cljs.core/not","devtools.munging/get-basis","devtools.munging/parse-constructor-info","goog/isObject","type-name","parts","basis","e56043","devtools.munging/protocol-path","protocol-selector","devtools.munging/get-protocol-object","obj","path","devtools.munging/protocol-exists?","devtools.munging/get-protocol-selector","key","clojure.string/includes?","devtools.munging/demunge-protocol-selector","devtools.munging/fast-path-protocols-lookup-table","cljs.core/Delay","devtools.munging/key-for-protocol-partition","partition","devtools.munging/scan-fast-path-protocols-partition","partition-key","partition-bits","lookup-table","cljs.core/deref","cljs.core/map?","*","p__56066","vec__56067","accum","bit","protocol","devtools.munging/scan-fast-path-protocols","cljs.core/concat","cljs.core.partial.cljs$core$IFn$_invoke$arity$2","cljs.core.range.cljs$core$IFn$_invoke$arity$1","devtools.munging/scan-slow-path-protocols","keys","goog.object/getKeys","selectors","cljs.core.keep.cljs$core$IFn$_invoke$arity$2","devtools.munging/make-protocol-descriptor","selector","fast?","p__56073","vec__56074","devtools.munging/convert-to-protocol-descriptor","devtools.munging/protocol-descriptors-comparator","a","b","devtools.munging/scan-protocols","fast-path-protocols","slow-path-protocols","all-protocols","devtools.munging/collect-protocol-methods","key-prefix","pattern","cljs.core/re-pattern","all-keys","matches","methods","cljs.core/group-by","match-to-arity","cljs.core.nth.cljs$core$IFn$_invoke$arity$2","match-arity-comparator","post-process","p__56086","vec__56087","sorted-matches","p1__56085#","by-name-comparator"]]],"~:cache-keys",["~#cmap",[["^T","^11"],[1589208773000],["^1I","goog/math/math.js"],[1589208774923,"~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^L",[]],"~:deps-syms",["^14","~$goog.array","~$goog.asserts"]]],["^1I","goog/array/array.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^1["]]],["^1I","goog/debug/error.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14"]]],["^1I","goog/dom/nodetype.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14"]]],["^1I","goog/object/object.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14"]]],"~:SHADOW-TIMESTAMP",[1589208783000,1589208773000],["^1I","goog/math/long.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^1[","~$goog.reflect"]]],["^1I","goog/string/internal.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14"]]],["^1I","goog/functions/functions.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14"]]],["^1I","goog/structs/map.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^T","^H"],[1589208781000],["^1I","devtools/munging.cljs"],[1589208781405,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^11","^16","^17","^13","^["]]],["^1I","goog/asserts/asserts.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1I","goog/uri/uri.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^1Z","^1[","^1D","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1I","goog/base.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",[]]],["^1I","goog/structs/structs.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^1Z","^13"]]],["^1I","clojure/string.cljs"],[1589208773847,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^11","^1D","^["]]],["^1I","goog/string/string.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","~$goog.string.internal"]]],["^T","^E"],[1589208781000],["^1I","goog/reflect/reflect.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14"]]],["^1I","goog/string/stringbuffer.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14"]]],["^1I","goog/iter/iter.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^1Z","^1[","~$goog.functions","~$goog.math"]]],["^1I","cljs/core.cljs"],[1589208773847,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["~$goog.math.Long","~$goog.math.Integer","^1D","^13","^1Z","~$goog.Uri","^["]]],["^1I","devtools/context.cljs"],[1589208781405,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^11"]]],["^1I","goog/math/integer.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14"]]],["^1I","goog/uri/utils.js"],[1589208774923,"^1V",["^ ","^1W",null,"^1X",["^L",[]],"^1Y",["^14","^1Z","^1[","^1D"]]]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","This namespace implements various heuristics to map Javascript names back to corresponding ClojureScript names.\n  The functionality here heavily depends on observed ClojureScript compiler and runtime behaviour (fragile!).\n  Answers given by functions in this namespace cannot be perfect because generated Javascript naming schemes produced by\n  ClojureScript compiler were not designed with easy reversibility in mind. We recommend this functionality to be used for\n  presentation in the UI only. The goal here is to provide user with more familiar view of runtime state of her app\n  in most common cases (on best effort basis).\n\n  Our main weapons in this uneven fight are:\n    1. munged function names as they appear in Javascript (generated by ClojureScript)\n    2. we can also analyze function sources accessible via .toString\n    3. special cljs$core$IFn$_invoke protocol props generated for multi-arity functions\n\n  We can also cheat and look at runtime state of browser environment to determine some answers about namespaces.\n\n  This code can be used only in non-advanced builds!\n\n  If you discovered breakage or a new case which should be covered by this code, please open an issue:\n    https://github.com/binaryage/cljs-devtools/issues","^7","devtools/munging.cljs","^8",1,"^9",5,"^:",1,"^;",21],"^<",["^ ","^=","^>","^?","^@","^A","^B"],"^C",["^ ","^D","^E","^F","^E","^G","^H","^I","^H","^J","^H"],"^K",["^L",["^M"]],"^N",["^ ","^D",["^ ","^O",["^P",[[]]],"^8",28,"^9",1,"^7","devtools/munging.clj","^Q","^R","^S","^E","^T",true],"^F",["^ ","^O",["^P",[[]]],"^8",21,"^9",1,"^7","devtools/munging.clj","^Q","^U","^S","^E","^T",true],"^V",["^ ","^O",["^P",[[]]],"^8",12,"^9",1,"^7","devtools/munging.clj","^Q","^W","^S","^E","^T",true]],"^Q","^E","^Y",["^ ","^Z","^["],"^10",["^ ","^11","^11","^12","^13","^14","^14","^13","^13","^[","^[","^Z","^[","^15","^16","^17","^17","^16","^16","^18","^17"],"^19",["^L",["^1:","^1;"]],"~:shadow/js-access-global",["^L",["String","Error","parseInt"]],"^1<",null,"~:defs",["^ ","~$args-lists-to-strings",["^ ","~:protocol-inline",null,"^5",["^ ","^7","devtools/munging.cljs","^8",446,"^9",7,"^:",446,"^;",28,"^O",["^P",["~$quote",["^P",[["~$args-lists","~$spacer-symbol","~$multi-arity-symbol","~$rest-symbol"]]]]],"^6","Converts a list of arguments lists into a list of strings suitable for UI presentation."],"^Q","~$devtools.munging/args-lists-to-strings","^7","devtools/munging.cljs","^;",28,"~:method-params",["^P",[["^2G","^2H","^2I","^2J"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^9",1,"~:variadic?",false,"^8",446,"~:ret-tag","~$cljs.core/LazySeq","^:",446,"~:max-fixed-arity",4,"~:fn-var",true,"^O",["^P",["^2F",["^P",[["^2G","^2H","^2I","^2J"]]]]],"^6","Converts a list of arguments lists into a list of strings suitable for UI presentation."],"~$get-basis",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",506,"^9",7,"^:",506,"^;",16,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"^Q","~$devtools.munging/get-basis","^7","devtools/munging.cljs","^;",16,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",506,"^2P","~$any","^:",506,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"~$humanize-name",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",338,"^9",7,"^:",338,"^;",20,"^O",["^P",["^2F",["^P",[["~$state","~$name"]]]]],"^6","Given a name and intermediate state. Convert name to a human readable version by keeping human readable prefix with\n  optional subscribt postfix and store it in ::result. Subscript number is picked based on state. State keeps track of\n  previously assigned subscripts. Returns a new state."],"^Q","~$devtools.munging/humanize-name","^7","devtools/munging.cljs","^;",20,"^2L",["^P",[["^2X","^2Y"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",338,"^2P",["^L",["~$clj","^2V"]],"^:",338,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["^2X","^2Y"]]]]],"^6","Given a name and intermediate state. Convert name to a human readable version by keeping human readable prefix with\n  optional subscribt postfix and store it in ::result. Subscript number is picked based on state. State keeps track of\n  previously assigned subscripts. Returns a new state."],"~$find-index-of-human-prefix",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",324,"^9",7,"^:",324,"^;",33,"^O",["^P",["^2F",["^P",[["^2Y"]]]]],"^6","Given a demunged ClojureScript parameter name. Tries to detect human readable part and returns the index where it ends.\n  Returns nil if no prefix can be detected.\n\n  The idea is to convert macro-generated parameters and other generated names to more friendly names.\n  We observed that param names generated by gensym have prefix followed by big numbers.\n  Other generated names contain two dashes after prefix (originally probably using underscores)."],"^Q","~$devtools.munging/find-index-of-human-prefix","^7","devtools/munging.cljs","^;",33,"^2L",["^P",[["^2Y"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",324,"^2P",["^L",["^2V","~$clj-nil"]],"^:",324,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^2Y"]]]]],"^6","Given a demunged ClojureScript parameter name. Tries to detect human readable part and returns the index where it ends.\n  Returns nil if no prefix can be detected.\n\n  The idea is to convert macro-generated parameters and other generated names to more friendly names.\n  We observed that param names generated by gensym have prefix followed by big numbers.\n  Other generated names contain two dashes after prefix (originally probably using underscores)."],"~$protocol-descriptors-comparator",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",588,"^9",7,"^:",588,"^;",38,"^O",["^P",["^2F",["^P",[["~$a","~$b"]]]]]],"^Q","~$devtools.munging/protocol-descriptors-comparator","^7","devtools/munging.cljs","^;",38,"^2L",["^P",[["~$a","~$b"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",588,"^2P","~$number","^:",588,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["~$a","~$b"]]]]]],"~$make-subscript",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",86,"^9",7,"^:",86,"^;",21,"^O",["^P",["^2F",["^P",[["~$subscript"]]]]],"^6","Given a subscript number converts it into a string representation consisting of unicode subscript characters (digits)."],"^Q","~$devtools.munging/make-subscript","^7","devtools/munging.cljs","^;",21,"^2L",["^P",[["^37"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",86,"^2P","^15","^:",86,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^37"]]]]],"^6","Given a subscript number converts it into a string representation consisting of unicode subscript characters (digits)."],"~$trivial-fn-source?",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",138,"^9",7,"^:",138,"^;",25,"^O",["^P",["^2F",["^P",[["~$fn-source"]]]]]],"^Q","~$devtools.munging/trivial-fn-source?","^7","devtools/munging.cljs","^;",25,"^2L",["^P",[["^3:"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",138,"^2P","~$boolean","^:",138,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3:"]]]]]],"~$char-to-subscript",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",75,"^9",7,"^:",75,"^;",24,"^O",["^P",["^2F",["^P",[["~$char"]]]]],"^6","Given a character with a single digit converts it into a subscript character.\n  Zero chracter maps to unicode 'SUBSCRIPT ZERO' (U+2080)."],"^Q","~$devtools.munging/char-to-subscript","^7","devtools/munging.cljs","^;",24,"^2L",["^P",[["^3>"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",75,"^2P","^2V","^:",75,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3>"]]]]],"^6","Given a character with a single digit converts it into a subscript character.\n  Zero chracter maps to unicode 'SUBSCRIPT ZERO' (U+2080)."],"~$proper-arg-demunge",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",187,"^9",7,"^:",187,"^;",25,"^O",["^P",["^2F",["^P",[["~$munged-arg-name"]]]]]],"^Q","~$devtools.munging/proper-arg-demunge","^7","devtools/munging.cljs","^;",25,"^2L",["^P",[["^3A"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",187,"^2P","^15","^:",187,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3A"]]]]]],"^M",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",39,"^9",7,"^:",39,"^;",19,"^O",["^P",["^2F",["^P",[["~$x"]]]]]],"^Q","~$devtools.munging/js-reserved?","^7","devtools/munging.cljs","^;",19,"^2L",["^P",[["~$x"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",39,"^2P",["^L",["^2V","^32"]],"^:",39,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$x"]]]]]],"~$fast-path-protocols-lookup-table",["^ ","^Q","~$devtools.munging/fast-path-protocols-lookup-table","^7","devtools/munging.cljs","^8",552,"^9",1,"^:",552,"^;",38,"^5",["^ ","^7","devtools/munging.cljs","^8",552,"^9",6,"^:",552,"^;",38],"~:tag","~$cljs.core/Delay"],"~$present-fn-part",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",472,"^9",7,"^:",472,"^;",22,"^O",["^P",["^2F",["^P",[["~$fn-ns","~$fn-name","~$include-ns?"]]]]]],"^Q","~$devtools.munging/present-fn-part","^7","devtools/munging.cljs","^;",22,"^2L",["^P",[["^3I","^3J","^3K"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",472,"^2P","^15","^:",472,"^2R",3,"^2S",true,"^O",["^P",["^2F",["^P",[["^3I","^3J","^3K"]]]]]],"~$collect-fn-arities",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",391,"^9",7,"^:",391,"^;",25,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given a Javascript function object, tries to inspect known arity properties generated by ClojureScript compiler and\n  collects all available arity functions into a map. Arities are keyed by arity count and variadic arity gets ::variadic key."],"^Q","~$devtools.munging/collect-fn-arities","^7","devtools/munging.cljs","^;",25,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",391,"^2P",["^L",[null,"^2[","^2V","^32"]],"^:",391,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given a Javascript function object, tries to inspect known arity properties generated by ClojureScript compiler and\n  collects all available arity functions into a map. Arities are keyed by arity count and variadic arity gets ::variadic key."],"~$protocol-path",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",523,"^9",7,"^:",523,"^;",20,"^O",["^P",["^2F",["^P",[["~$protocol-selector"]]]]]],"^Q","~$devtools.munging/protocol-path","^7","devtools/munging.cljs","^;",20,"^2L",["^P",[["^3P"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",523,"^2P","^2V","^:",523,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3P"]]]]]],"~$key-for-protocol-partition",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",554,"^9",7,"^:",554,"^;",33,"^O",["^P",["^2F",["^P",[["~$partition"]]]]]],"^Q","~$devtools.munging/key-for-protocol-partition","^7","devtools/munging.cljs","^;",33,"^2L",["^P",[["^3S"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",554,"^2P","^15","^:",554,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3S"]]]]]],"~$collect-protocol-methods",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",597,"^9",7,"^:",597,"^;",31,"^O",["^P",["^2F",["^P",[["~$obj","^3P"]]]]]],"^Q","~$devtools.munging/collect-protocol-methods","^7","devtools/munging.cljs","^;",31,"^2L",["^P",[["^3V","^3P"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",597,"^2P",["^L",["~$seq","~$cljs.core/IList"]],"^:",597,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["^3V","^3P"]]]]]],"~$reserved-aware-demunge",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",179,"^9",7,"^:",179,"^;",29,"^O",["^P",["^2F",["^P",[["~$munged-name"]]]]]],"^Q","~$devtools.munging/reserved-aware-demunge","^7","devtools/munging.cljs","^;",29,"^2L",["^P",[["^3["]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",179,"^2P",["^L",[null,"^2V"]],"^:",179,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3["]]]]]],"~$arity-keywords-comparator",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",404,"^9",7,"^:",404,"^;",32,"^O",["^P",["^2F",["^P",[["~$x","~$y"]]]]],"^6","::variadic goes last, other keywords compare by name."],"^Q","~$devtools.munging/arity-keywords-comparator","^7","devtools/munging.cljs","^;",32,"^2L",["^P",[["~$x","~$y"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",404,"^2P","^35","^:",404,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["~$x","~$y"]]]]],"^6","::variadic goes last, other keywords compare by name."],"~$extract-arities",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",463,"^9",7,"^:",463,"^;",22,"^O",["^P",["^2F",["^P",[["~$f","~$humanize?","^2H","^2I","^2J"]]]]]],"^Q","~$devtools.munging/extract-arities","^7","devtools/munging.cljs","^;",22,"^2L",["^P",[["~$f","^44","^2H","^2I","^2J"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",463,"^2P","^2Q","^:",463,"^2R",5,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f","^44","^2H","^2I","^2J"]]]]]],"~$arities-key-comparator",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",412,"^9",7,"^:",412,"^;",29,"^O",["^P",["^2F",["^P",[["~$x","~$y"]]]]],"^6","numbers go first (ordered), then keywords (ordered by name), and then ::variadic sticks last"],"^Q","~$devtools.munging/arities-key-comparator","^7","devtools/munging.cljs","^;",29,"^2L",["^P",[["~$x","~$y"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",412,"^2P","^35","^:",412,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["~$x","~$y"]]]]],"^6","numbers go first (ordered), then keywords (ordered by name), and then ::variadic sticks last"],"~$get-fn-max-fixed-arity",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",58,"^9",7,"^:",58,"^;",29,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"^Q","~$devtools.munging/get-fn-max-fixed-arity","^7","devtools/munging.cljs","^;",29,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",58,"^2P","^2V","^:",58,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"~$common-protocol?",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",468,"^9",7,"^:",468,"^;",23,"^O",["^P",["^2F",["^P",[["~$protocol-ns","~$protocol-name"]]]]]],"^Q","~$devtools.munging/common-protocol?","^7","devtools/munging.cljs","^;",23,"^2L",["^P",[["^4;","^4<"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",468,"^2P","^3<","^:",468,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["^4;","^4<"]]]]]],"~$break-munged-name",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",240,"^9",7,"^:",240,"^;",24,"^O",["^P",["^2F",["^P",[["^3["],["^3[","~$ns-detector"]]]]],"^6","Given a munged-name from Javascript lands attempts to break it into:\n  [fn-ns fn-name protocol-ns protocol-name protocol-method arity].\n\n  Protocol and arity elements are optional. Function elements are always present or \"\".\n\n  examples for input:\n    cljs$core$rest => ['cljs.core', 'rest']\n    cljs.core.reduce$cljs$core$IFn$_invoke$arity$3 => ['cljs.core' 'reduce' 'cljs.core' 'IFn' '_invoke' 3]","~:top-fn",["^ ","^2O",false,"~:fixed-arity",2,"^2R",2,"^2L",[["^3["],["^3[","^4?"]],"^O",["^P",[["^3["],["^3[","^4?"]]],"^2N",["^P",[null,null]]]],"^Q","~$devtools.munging/break-munged-name","^7","devtools/munging.cljs","^;",24,"^4@",["^ ","^2O",false,"^4A",2,"^2R",2,"^2L",[["^3["],["^3[","^4?"]],"^O",["^P",[["^3["],["^3[","^4?"]]],"^2N",["^P",[null,null]]],"^2L",[["^3["],["^3[","^4?"]],"^2M",null,"^4A",2,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"~:methods",[["^ ","^4A",1,"^2O",false,"^3F","^2V"],["^ ","^4A",2,"^2O",false,"^3F","~$cljs.core/IVector"]],"^8",240,"^:",240,"^2R",2,"^2S",true,"^O",["^P",[["^3["],["^3[","^4?"]]],"^6","Given a munged-name from Javascript lands attempts to break it into:\n  [fn-ns fn-name protocol-ns protocol-name protocol-method arity].\n\n  Protocol and arity elements are optional. Function elements are always present or \"\".\n\n  examples for input:\n    cljs$core$rest => ['cljs.core', 'rest']\n    cljs.core.reduce$cljs$core$IFn$_invoke$arity$3 => ['cljs.core' 'reduce' 'cljs.core' 'IFn' '_invoke' 3]"],"~$present-function-name",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",483,"^9",7,"^:",483,"^;",28,"^O",["^P",["^2F",["^P",[["^3[","~$options"]]]]],"^6","Given javascript function name tries to present it as plain string for display in UI on best effort basis."],"^Q","~$devtools.munging/present-function-name","^7","devtools/munging.cljs","^;",28,"^2L",["^P",[["^3[","^4F"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",483,"^2P",["^L",[null,"^15"]],"^:",483,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["^3[","^4F"]]]]],"^6","Given javascript function name tries to present it as plain string for display in UI on best effort basis."],"~$char-to-superscript",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",92,"^9",7,"^:",92,"^;",26,"^O",["^P",["^2F",["^P",[["^3>"]]]]],"^6","Given a character with a single digit converts it into a superscript character.\n  Zero chracter maps to unicode 'SUPERSCRIPT ZERO' (U+2070)."],"^Q","~$devtools.munging/char-to-superscript","^7","devtools/munging.cljs","^;",26,"^2L",["^P",[["^3>"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",92,"^2P","^2V","^:",92,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3>"]]]]],"^6","Given a character with a single digit converts it into a superscript character.\n  Zero chracter maps to unicode 'SUPERSCRIPT ZERO' (U+2070)."],"~$get-fn-variadic-arity",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",55,"^9",7,"^:",55,"^;",28,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"^Q","~$devtools.munging/get-fn-variadic-arity","^7","devtools/munging.cljs","^;",28,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",55,"^2P","^2V","^:",55,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"~$scan-protocols",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",591,"^9",7,"^:",591,"^;",21,"^O",["^P",["^2F",["^P",[["^3V"]]]]]],"^Q","~$devtools.munging/scan-protocols","^7","devtools/munging.cljs","^;",21,"^2L",["^P",[["^3V"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",591,"^2P",["^L",["^3X","^3Y"]],"^:",591,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3V"]]]]]],"~$get-protocol-object",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",526,"^9",7,"^:",526,"^;",26,"^O",["^P",["^2F",["^P",[["^3P"]]]]]],"^Q","~$devtools.munging/get-protocol-object","^7","devtools/munging.cljs","^;",26,"^2L",["^P",[["^3P"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",526,"^2P",["^L",["^2V","^32"]],"^:",526,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3P"]]]]]],"~$parse-fn-source",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",123,"^9",7,"^:",123,"^;",22,"^O",["^P",["^2F",["^P",[["^3:"]]]]],"^6","Given a function source code parses out [name args]. Note that both strings are still munged.\n  Suitable for further processing.\n\n  For exampe for input below the function will return [\"devtools_sample$core$hello\" \"name, unused_param\"]:\n\n  function devtools_sample$core$hello(name, unused_param){\n    return [cljs.core.str(\"hello, \"),cljs.core.str(name),cljs.core.str(\"!\")].join('');\n  }\n  "],"^Q","~$devtools.munging/parse-fn-source","^7","devtools/munging.cljs","^;",22,"^2L",["^P",[["^3:"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",123,"^2P",["^L",["^3X","^32"]],"^:",123,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3:"]]]]],"^6","Given a function source code parses out [name args]. Note that both strings are still munged.\n  Suitable for further processing.\n\n  For exampe for input below the function will return [\"devtools_sample$core$hello\" \"name, unused_param\"]:\n\n  function devtools_sample$core$hello(name, unused_param){\n    return [cljs.core.str(\"hello, \"),cljs.core.str(name),cljs.core.str(\"!\")].join('');\n  }\n  "],"~$ns-exists?",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",197,"^9",7,"^:",197,"^;",17,"^O",["^P",["^2F",["^P",[["~$ns-module-name"]]]]]],"^Q","~$devtools.munging/ns-exists?","^7","devtools/munging.cljs","^;",17,"^2L",["^P",[["^4S"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",197,"^2P",["^L",["^3<","^32"]],"^:",197,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^4S"]]]]]],"~$get-protocol-selector",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",537,"^9",7,"^:",537,"^;",28,"^O",["^P",["^2F",["^P",[["~$key"]]]]]],"^Q","~$devtools.munging/get-protocol-selector","^7","devtools/munging.cljs","^;",28,"^2L",["^P",[["^4V"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",537,"^2P",["^L",["^15","^32"]],"^:",537,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^4V"]]]]]],"~$convert-to-protocol-descriptor",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",585,"^9",7,"^:",585,"^;",37,"^O",["^P",["^2F",["^P",[["~$fast?",["^1>","^2Y","~$selector"]]]]]]],"^Q","~$devtools.munging/convert-to-protocol-descriptor","^7","devtools/munging.cljs","^;",37,"^2L",["^P",[["^4Y","~$p__56073"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",585,"^2P","~$cljs.core/IMap","^:",585,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["^4Y",["^1>","^2Y","^4Z"]]]]]]],"~$review-arities",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",383,"^9",7,"^:",383,"^;",21,"^O",["^P",["^2F",["^P",[["~$arities"]]]]],"^6","Some arities can be marked as fixed arity but in fact point to a variadic-arity function. We want to detect this case\n  and turn such improperly categorized arities to ::variadic."],"^Q","~$devtools.munging/review-arities","^7","devtools/munging.cljs","^;",21,"^2L",["^P",[["^53"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",383,"^2P",["^L",[null,"^2[","^2V"]],"^:",383,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^53"]]]]],"^6","Some arities can be marked as fixed arity but in fact point to a variadic-arity function. We want to detect this case\n  and turn such improperly categorized arities to ::variadic."],"~$scan-fast-path-protocols-partition",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",557,"^9",7,"^:",557,"^;",41,"^O",["^P",["^2F",["^P",[["^3V","^3S"]]]]]],"^Q","~$devtools.munging/scan-fast-path-protocols-partition","^7","devtools/munging.cljs","^;",41,"^2L",["^P",[["^3V","^3S"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",557,"^2P",["^L",[null,"^2V","^32"]],"^:",557,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["^3V","^3S"]]]]]],"~$proper-ns-demunge",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",192,"^9",7,"^:",192,"^;",24,"^O",["^P",["^2F",["^P",[["~$munged-ns-name"]]]]]],"^Q","~$devtools.munging/proper-ns-demunge","^7","devtools/munging.cljs","^;",24,"^2L",["^P",[["^58"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",192,"^2P","^15","^:",192,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^58"]]]]]],"~$strip-arity",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",226,"^9",7,"^:",226,"^;",18,"^O",["^P",["^2F",["^P",[["~$tokens"]]]]]],"^Q","~$devtools.munging/strip-arity","^7","devtools/munging.cljs","^;",18,"^2L",["^P",[["^5;"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",226,"^2P","^4D","^:",226,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^5;"]]]]]],"~$scan-slow-path-protocols",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",574,"^9",7,"^:",574,"^;",31,"^O",["^P",["^2F",["^P",[["^3V"]]]]]],"^Q","~$devtools.munging/scan-slow-path-protocols","^7","devtools/munging.cljs","^;",31,"^2L",["^P",[["^3V"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",574,"^2P","^2Q","^:",574,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3V"]]]]]],"~$arities-to-args-lists",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",433,"^9",7,"^:",433,"^;",28,"^O",["^P",["^2F",["^P",[["^53","~$&",["^44"]]]]]],"^6","Given a map of arity functions. Tries to parse individual functions and prepare an arguments list for each arity.\n  Returned list of arguments list is sorted by arity count, variadic arity goes last if available.\n\n  The function also optionally humanizes argument names in each arguments list if requested.","^4@",["^ ","^2O",true,"^4A",1,"^2R",1,"^2L",[["^P",["^53",["^44"]]]],"^O",["^P",[["^53","~$&",["^44"]]]],"^2N",["^P",[null]]]],"^Q","~$devtools.munging/arities-to-args-lists","^7","devtools/munging.cljs","^;",28,"^4@",["^ ","^2O",true,"^4A",1,"^2R",1,"^2L",[["^P",["^53",["^44"]]]],"^O",["^P",[["^53","~$&",["^44"]]]],"^2N",["^P",[null]]],"^2L",[["^P",["^53",["^44"]]]],"^2M",null,"^4A",1,"^2N",["^P",[null]],"^9",1,"^2O",true,"^4C",[["^ ","^4A",1,"^2O",true,"^3F","^2Q"]],"^8",433,"^2P","^2V","^:",433,"^2R",1,"^2S",true,"^O",["^P",[["^53","~$&",["^44"]]]],"^6","Given a map of arity functions. Tries to parse individual functions and prepare an arguments list for each arity.\n  Returned list of arguments list is sorted by arity count, variadic arity goes last if available.\n\n  The function also optionally humanizes argument names in each arguments list if requested."],"~$collect-fn-variadic-arities",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",373,"^9",7,"^:",373,"^;",34,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"^Q","~$devtools.munging/collect-fn-variadic-arities","^7","devtools/munging.cljs","^;",34,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",373,"^2P",["^L",["^51","^32"]],"^:",373,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"~$get-fn-fixed-arity",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",52,"^9",7,"^:",52,"^;",25,"^O",["^P",["^2F",["^P",[["~$f","~$n"]]]]]],"^Q","~$devtools.munging/get-fn-fixed-arity","^7","devtools/munging.cljs","^;",25,"^2L",["^P",[["~$f","~$n"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",52,"^2P","^2V","^:",52,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f","~$n"]]]]]],"~$dollar-replacement",["^ ","^Q","~$devtools.munging/dollar-replacement","^7","devtools/munging.cljs","^8",31,"^9",1,"^:",31,"^;",24,"^5",["^ ","^7","devtools/munging.cljs","^8",31,"^9",6,"^:",31,"^;",24],"^3F","^15"],"~$get-global-scope",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",36,"^9",17,"^:",36,"^;",33,"~:dynamic",true,"^O",["^P",["^2F",["^P",[[]]]]]],"^Q","~$devtools.munging/get-global-scope","^7","devtools/munging.cljs","^;",33,"^2L",["^P",[[]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^5H",true,"^8",36,"^2P","^2V","^:",36,"^2R",0,"^2S",true,"^O",["^P",["^2F",["^P",[[]]]]]],"~$revert-reserved",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",173,"^9",7,"^:",173,"^;",22,"^O",["^P",["^2F",["^P",[["~$s"]]]]]],"^Q","~$devtools.munging/revert-reserved","^7","devtools/munging.cljs","^;",22,"^2L",["^P",[["~$s"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",173,"^2P",["^L",[null,"^2V"]],"^:",173,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$s"]]]]]],"~$detect-namespace-prefix",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",202,"^9",7,"^:",202,"^;",30,"^O",["^P",["^2F",["^P",[["^5;","~$&",["^4?"]]]]]],"^6","Given a name broken into namespace parts returns [detected-ns remaining-parts],\n  where detected-ns is a string representing longest detected existing namespace and\n  remaining-parts is a vector of remaing input parts not included in the detected-ns concatenation.\n\n  For given input [\"cljs\" \"core\" \"first\"] returns [\"cljs.core\" [\"first\"]] (asumming cljs.core exists)","^4@",["^ ","^2O",true,"^4A",1,"^2R",1,"^2L",[["^P",["^5;",["^4?"]]]],"^O",["^P",[["^5;","~$&",["^4?"]]]],"^2N",["^P",[null]]]],"^Q","~$devtools.munging/detect-namespace-prefix","^7","devtools/munging.cljs","^;",30,"^4@",["^ ","^2O",true,"^4A",1,"^2R",1,"^2L",[["^P",["^5;",["^4?"]]]],"^O",["^P",[["^5;","~$&",["^4?"]]]],"^2N",["^P",[null]]],"^2L",[["^P",["^5;",["^4?"]]]],"^2M",null,"^4A",1,"^2N",["^P",[null]],"^9",1,"^2O",true,"^4C",[["^ ","^4A",1,"^2O",true,"^3F","^4D"]],"^8",202,"^2P","^2V","^:",202,"^2R",1,"^2S",true,"^O",["^P",[["^5;","~$&",["^4?"]]]],"^6","Given a name broken into namespace parts returns [detected-ns remaining-parts],\n  where detected-ns is a string representing longest detected existing namespace and\n  remaining-parts is a vector of remaing input parts not included in the detected-ns concatenation.\n\n  For given input [\"cljs\" \"core\" \"first\"] returns [\"cljs.core\" [\"first\"]] (asumming cljs.core exists)"],"~$parse-fn-info-deep",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",303,"^9",7,"^:",303,"^;",25,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given a Javascript function object tries to retrieve [ns name & args] as in parse-fn-info (on best effort basis).\n\n  The difference from parse-fn-info is that this function prefers to read args from arities if available.\n  It recurses arbitrary deep following IFn protocol leads.\n\n  If we hit multi-arity situation in leaf, we don't attempt to list arguments and return ::multi-arity placeholder instead.\n\n  The reason for reading arities is that it gives more accurate parameter names in some cases.\n  We observed that variadic functions don't always contain original parameter names, but individual IFn arity functions do."],"^Q","~$devtools.munging/parse-fn-info-deep","^7","devtools/munging.cljs","^;",25,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",303,"^2P","^2[","^:",303,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given a Javascript function object tries to retrieve [ns name & args] as in parse-fn-info (on best effort basis).\n\n  The difference from parse-fn-info is that this function prefers to read args from arities if available.\n  It recurses arbitrary deep following IFn protocol leads.\n\n  If we hit multi-arity situation in leaf, we don't attempt to list arguments and return ::multi-arity placeholder instead.\n\n  The reason for reading arities is that it gives more accurate parameter names in some cases.\n  We observed that variadic functions don't always contain original parameter names, but individual IFn arity functions do."],"~$parse-fn-source-info",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",282,"^9",7,"^:",282,"^;",27,"^O",["^P",["^2F",["^P",[["^3:"]]]]],"^6","Given function source code tries to retrieve [ns name & args] on best effort basis, where\n  ns is demunged namespace part of the function name (or \"\" if namespace cannot be detected)\n  name is demunged short name (or \"\" if function is anonymous or name cannot be retrieved)\n  args is optional number of demunged argument names.\n\n  Please note that this function always returns a vector with something. In worst cases [\"\" \"\"].\n  "],"^Q","~$devtools.munging/parse-fn-source-info","^7","devtools/munging.cljs","^;",27,"^2L",["^P",[["^3:"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",282,"^2P","^2[","^:",282,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3:"]]]]],"^6","Given function source code tries to retrieve [ns name & args] on best effort basis, where\n  ns is demunged namespace part of the function name (or \"\" if namespace cannot be detected)\n  name is demunged short name (or \"\" if function is anonymous or name cannot be retrieved)\n  args is optional number of demunged argument names.\n\n  Please note that this function always returns a vector with something. In worst cases [\"\" \"\"].\n  "],"~$arities-to-args-lists*",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",423,"^9",7,"^:",423,"^;",29,"^O",["^P",["^2F",["^P",[["^53"]]]]]],"^Q","~$devtools.munging/arities-to-args-lists*","^7","devtools/munging.cljs","^;",29,"^2L",["^P",[["^53"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",423,"^2P","^2Q","^:",423,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^53"]]]]]],"~$cljs-fn-name?",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",115,"^9",7,"^:",115,"^;",20,"^O",["^P",["^2F",["^P",[["^3["]]]]],"^6","Given a Javascript name answers if the name was likely generated by ClojureScript.\n  We use a simple heuristic here:\n    The name must contain at least two separate dollars because we assume two-segment namespaces."],"^Q","~$devtools.munging/cljs-fn-name?","^7","devtools/munging.cljs","^;",20,"^2L",["^P",[["^3["]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",115,"^2P",["^L",["^3<","^32"]],"^:",115,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3["]]]]],"^6","Given a Javascript name answers if the name was likely generated by ClojureScript.\n  We use a simple heuristic here:\n    The name must contain at least two separate dollars because we assume two-segment namespaces."],"~$break-and-demunge-name",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",265,"^9",7,"^:",265,"^;",29,"^O",["^P",["^2F",["^P",[["^3["],["^3[","^4?"]]]]],"^6","Given a munged-name from Javascript lands attempts to break it into a namespace part and remaining short name.\n  Then applies appropriate demunging on them and returns ClojureScript versions of the names.","^4@",["^ ","^2O",false,"^4A",2,"^2R",2,"^2L",[["^3["],["^3[","^4?"]],"^O",["^P",[["^3["],["^3[","^4?"]]],"^2N",["^P",[null,null]]]],"^Q","~$devtools.munging/break-and-demunge-name","^7","devtools/munging.cljs","^;",29,"^4@",["^ ","^2O",false,"^4A",2,"^2R",2,"^2L",[["^3["],["^3[","^4?"]],"^O",["^P",[["^3["],["^3[","^4?"]]],"^2N",["^P",[null,null]]],"^2L",[["^3["],["^3[","^4?"]],"^2M",null,"^4A",2,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^4C",[["^ ","^4A",1,"^2O",false,"^3F","^2V"],["^ ","^4A",2,"^2O",false,"^3F","^4D"]],"^8",265,"^:",265,"^2R",2,"^2S",true,"^O",["^P",[["^3["],["^3[","^4?"]]],"^6","Given a munged-name from Javascript lands attempts to break it into a namespace part and remaining short name.\n  Then applies appropriate demunging on them and returns ClojureScript versions of the names."],"~$parse-constructor-info",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",509,"^9",7,"^:",509,"^;",29,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given a Javascript constructor function tries to retrieve [ns name basis]. Returns nil if not a cljs type."],"^Q","~$devtools.munging/parse-constructor-info","^7","devtools/munging.cljs","^;",29,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",509,"^2P",["^L",["^2[","^32"]],"^:",509,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given a Javascript constructor function tries to retrieve [ns name basis]. Returns nil if not a cljs type."],"~$collect-fn-fixed-arities",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",364,"^9",7,"^:",364,"^;",31,"^O",["^P",["^2F",["^P",[["~$f","~$max-arity"]]]]]],"^Q","~$devtools.munging/collect-fn-fixed-arities","^7","devtools/munging.cljs","^;",31,"^2L",["^P",[["~$f","^5["]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",364,"^2P","^2V","^:",364,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f","^5["]]]]]],"~$get-fn-source-safely",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",44,"^9",7,"^:",44,"^;",27,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"^Q","~$devtools.munging/get-fn-source-safely","^7","devtools/munging.cljs","^;",27,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",44,"^:",44,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]]],"~$cljs-fn?",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",144,"^9",7,"^:",144,"^;",15,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given a Javascript function object returns true if the function looks like a ClojureScript function.\n\n  Uses various heuristics:\n    1. must be fn? (is javascript function or satisfies Fn and IFn protocols)\n    2. and name must be cljs-fn-name? (name can come from f.name or parsed out of function source)\n    3. or if anonymous function, must be non-trivial"],"^Q","~$devtools.munging/cljs-fn?","^7","devtools/munging.cljs","^;",15,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",144,"^2P",["^L",["^3<","^32"]],"^:",144,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given a Javascript function object returns true if the function looks like a ClojureScript function.\n\n  Uses various heuristics:\n    1. must be fn? (is javascript function or satisfies Fn and IFn protocols)\n    2. and name must be cljs-fn-name? (name can come from f.name or parsed out of function source)\n    3. or if anonymous function, must be non-trivial"],"~$protocol-exists?",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",534,"^9",7,"^:",534,"^;",23,"^O",["^P",["^2F",["^P",[["^3P"]]]]]],"^Q","~$devtools.munging/protocol-exists?","^7","devtools/munging.cljs","^;",23,"^2L",["^P",[["^3P"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",534,"^2P","^3<","^:",534,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3P"]]]]]],"~$parse-fn-info",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",297,"^9",7,"^:",297,"^;",20,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given Javascript function object tries to retrieve [ns name & args] as in parse-fn-source-info (on best effort basis)."],"^Q","~$devtools.munging/parse-fn-info","^7","devtools/munging.cljs","^;",20,"^2L",["^P",[["~$f"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",297,"^2P","^2[","^:",297,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$f"]]]]],"^6","Given Javascript function object tries to retrieve [ns name & args] as in parse-fn-source-info (on best effort basis)."],"~$make-superscript",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",107,"^9",7,"^:",107,"^;",23,"^O",["^P",["^2F",["^P",[["~$superscript"]]]]],"^6","Given a superscript number converts it into a string representation consisting of unicode superscript characters (digits)."],"^Q","~$devtools.munging/make-superscript","^7","devtools/munging.cljs","^;",23,"^2L",["^P",[["^6:"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",107,"^2P","^15","^:",107,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^6:"]]]]],"^6","Given a superscript number converts it into a string representation consisting of unicode superscript characters (digits)."],"~$demunge-protocol-selector",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",544,"^9",7,"^:",544,"^;",32,"^O",["^P",["^2F",["^P",[["^3P"]]]]]],"^Q","~$devtools.munging/demunge-protocol-selector","^7","devtools/munging.cljs","^;",32,"^2L",["^P",[["^3P"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",544,"^2P","^4D","^:",544,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3P"]]]]]],"~$proper-demunge",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",184,"^9",7,"^:",184,"^;",21,"^O",["^P",["^2F",["^P",[["^3["]]]]]],"^Q","~$devtools.munging/proper-demunge","^7","devtools/munging.cljs","^;",21,"^2L",["^P",[["^3["]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",184,"^2P",["^L",[null,"^2V"]],"^:",184,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3["]]]]]],"~$normalize-arity",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",219,"^9",7,"^:",219,"^;",22,"^O",["^P",["^2F",["^P",[["~$arity-tokens"]]]]]],"^Q","~$devtools.munging/normalize-arity","^7","devtools/munging.cljs","^;",22,"^2L",["^P",[["^6A"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",219,"^2P",["^L",[null,"^32"]],"^:",219,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^6A"]]]]]],"~$present-protocol-part",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",477,"^9",7,"^:",477,"^;",28,"^O",["^P",["^2F",["^P",[["^4;","^4<","~$protocol-method","~$include-protocol-ns?"]]]]]],"^Q","~$devtools.munging/present-protocol-part","^7","devtools/munging.cljs","^;",28,"^2L",["^P",[["^4;","^4<","^6D","^6E"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",477,"^2P","^15","^:",477,"^2R",4,"^2S",true,"^O",["^P",["^2F",["^P",[["^4;","^4<","^6D","^6E"]]]]]],"~$parse-protocol",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",230,"^9",7,"^:",230,"^;",21,"^O",["^P",["^2F",["^P",[["^5;","~$detector"]]]]]],"^Q","~$devtools.munging/parse-protocol","^7","devtools/munging.cljs","^;",21,"^2L",["^P",[["^5;","^6H"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",230,"^2P","^4D","^:",230,"^2R",2,"^2S",true,"^O",["^P",["^2F",["^P",[["^5;","^6H"]]]]]],"~$humanize-names",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",353,"^9",7,"^:",353,"^;",21,"^O",["^P",["^2F",["^P",[["~$names"]]]]],"^6","Given a list of names, returns a list of human-readable versions of those names.\n  It detects human-readable prefix using a simple heuristics. When names repeat it assigns simple subscripts starting with 2.\n  Subscripts are assigned left-to-right.\n\n  Given [\"p--a\" \"p--b\" \"x\" \"p--c\"] returns [\"p\" \"p₂\" \"x\" \"p₃\"]"],"^Q","~$devtools.munging/humanize-names","^7","devtools/munging.cljs","^;",21,"^2L",["^P",[["^6K"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",353,"^2P",["^L",["^2[","~$cljs.core/MetaFn","^32"]],"^:",353,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^6K"]]]]],"^6","Given a list of names, returns a list of human-readable versions of those names.\n  It detects human-readable prefix using a simple heuristics. When names repeat it assigns simple subscripts starting with 2.\n  Subscripts are assigned left-to-right.\n\n  Given [\"p--a\" \"p--b\" \"x\" \"p--c\"] returns [\"p\" \"p₂\" \"x\" \"p₃\"]"],"~$review-arity",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",377,"^9",7,"^:",377,"^;",19,"^O",["^P",["^2F",["^P",[[["~$arity","~$arity-fn"]]]]]]],"^Q","~$devtools.munging/review-arity","^7","devtools/munging.cljs","^;",19,"^2L",["^P",[["~$p__55984"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",377,"^2P","^4D","^:",377,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[[["^6O","^6P"]]]]]]],"~$dollar-preserving-demunge",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",164,"^9",7,"^:",164,"^;",32,"^O",["^P",["^2F",["^P",[["^3["]]]]],"^6","Standard cljs.core/demunge is too agresive in replacing dollars.\n  This wrapper function works around it by leaving dollars intact."],"^Q","~$devtools.munging/dollar-preserving-demunge","^7","devtools/munging.cljs","^;",32,"^2L",["^P",[["^3["]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",164,"^2P","^15","^:",164,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3["]]]]],"^6","Standard cljs.core/demunge is too agresive in replacing dollars.\n  This wrapper function works around it by leaving dollars intact."],"~$scan-fast-path-protocols",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",571,"^9",7,"^:",571,"^;",31,"^O",["^P",["^2F",["^P",[["^3V"]]]]]],"^Q","~$devtools.munging/scan-fast-path-protocols","^7","devtools/munging.cljs","^;",31,"^2L",["^P",[["^3V"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",571,"^2P","^2V","^:",571,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["^3V"]]]]]],"~$max-fixed-arity-to-scan",["^ ","^Q","~$devtools.munging/max-fixed-arity-to-scan","^7","devtools/munging.cljs","^8",32,"^9",1,"^:",32,"^;",29,"^5",["^ ","^7","devtools/munging.cljs","^8",32,"^9",6,"^:",32,"^;",29],"^3F","^35"],"~$make-protocol-descriptor",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",579,"^9",7,"^:",579,"^;",31,"^O",["^P",["^2F",["^P",[["^1>","^2Y","^4Z","^4Y"]]]]]],"^Q","~$devtools.munging/make-protocol-descriptor","^7","devtools/munging.cljs","^;",31,"^2L",["^P",[["^1>","^2Y","^4Z","^4Y"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",579,"^2P","^51","^:",579,"^2R",4,"^2S",true,"^O",["^P",["^2F",["^P",[["^1>","^2Y","^4Z","^4Y"]]]]]],"~$get-type-name",["^ ","^2E",null,"^5",["^ ","^7","devtools/munging.cljs","^8",61,"^9",7,"^:",61,"^;",20,"^O",["^P",["^2F",["^P",[["~$t"]]]]]],"^Q","~$devtools.munging/get-type-name","^7","devtools/munging.cljs","^;",20,"^2L",["^P",[["~$t"]]],"^2M",null,"^2N",["^P",[null,null]],"^9",1,"^2O",false,"^8",61,"^2P","^15","^:",61,"^2R",1,"^2S",true,"^O",["^P",["^2F",["^P",[["~$t"]]]]]]],"^1;",["^ ","^E","^E","^H","^H","^11","^11"],"~:cljs.analyzer/constants",["^ ","^19",["^L",["~:selector","~:devtools.munging/variadic","~:else","~:include-protocol-ns?","~:ns-detector","^S","^Q","~:naked","~:fast?","~:devtools.munging/multi-arity","~:silence-common-protocols?","~:include-ns?","~:devtools.munging/result"]],"~:order",["^79","^7<","^73","^74","^77","^7;","^75","^7:","^76","^S","^Q","^72","^78"]],"^1E",["^ ","^1;",["^L",[]],"^1:",["^L",[]]],"^1F",["^ "],"^1G",["^14","^11","^16","^17","^13","^["]],"^S","^E","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1U",[["^7@","~:static-fns"],true,["^7@","~:elide-asserts"],false,["^7@","~:optimize-constants"],null,["^7@","^1L"],null,["^7@","~:external-config"],null,["^7@","~:tooling-config"],null,["^7@","~:emit-constants"],null,["^7@","~:load-tests"],null,["^7@","~:infer-externs"],true,["^7@","^1N"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^7@","~:fn-invoke-direct"],null,["^7@","~:source-map"],"/dev/null"]]]